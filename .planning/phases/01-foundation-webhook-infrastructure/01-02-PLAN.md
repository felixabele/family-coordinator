---
phase: 01-foundation-webhook-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/webhook/types.ts
  - src/webhook/signature.ts
  - src/webhook/parser.ts
  - src/webhook/routes.ts
  - src/queue/types.ts
  - src/queue/connection.ts
  - src/queue/producer.ts
  - src/state/idempotency.ts
autonomous: true

must_haves:
  truths:
    - "Webhook GET endpoint returns challenge string for WhatsApp verification"
    - "Webhook POST endpoint validates X-Hub-Signature-256 using raw body HMAC-SHA256"
    - "Webhook POST endpoint returns 200 within milliseconds, before any processing"
    - "Incoming messages are enqueued to BullMQ for async processing"
    - "Duplicate messages are detected via Redis idempotency check before enqueueing"
    - "Status update webhooks (sent/delivered/read) are acknowledged but not processed"
  artifacts:
    - path: "src/webhook/signature.ts"
      provides: "HMAC-SHA256 signature validation with timing-safe comparison"
      exports: ["validateWebhookSignature"]
    - path: "src/webhook/parser.ts"
      provides: "WhatsApp payload parsing, extracts messages from nested structure"
      exports: ["extractMessages"]
    - path: "src/webhook/routes.ts"
      provides: "GET /webhook (verification) and POST /webhook (receive) endpoints"
      exports: ["webhookRoutes"]
    - path: "src/queue/producer.ts"
      provides: "BullMQ queue for enqueuing incoming messages"
      exports: ["createMessageQueue"]
    - path: "src/queue/connection.ts"
      provides: "Redis connections for queue producer and worker (separate configs)"
      exports: ["createQueueConnection", "createWorkerConnection"]
    - path: "src/state/idempotency.ts"
      provides: "Redis-backed deduplication for WhatsApp message IDs"
      exports: ["IdempotencyStore"]
  key_links:
    - from: "src/webhook/routes.ts"
      to: "src/webhook/signature.ts"
      via: "validates signature before processing"
      pattern: "validateWebhookSignature"
    - from: "src/webhook/routes.ts"
      to: "src/queue/producer.ts"
      via: "enqueues parsed messages after validation"
      pattern: "messageQueue\\.add"
    - from: "src/webhook/routes.ts"
      to: "src/state/idempotency.ts"
      via: "checks for duplicate messages before enqueueing"
      pattern: "idempotency.*isProcessed"
    - from: "src/webhook/routes.ts"
      to: "src/webhook/parser.ts"
      via: "extracts messages from webhook payload"
      pattern: "extractMessages"
---

<objective>
Build the WhatsApp webhook server with signature validation, payload parsing, and async message enqueueing via BullMQ. This is the "front door" of the application.

Purpose: WhatsApp messages must be received securely (signature validation), acknowledged fast (200 within milliseconds), and queued reliably (BullMQ) for background processing. Without this, the bot cannot receive or respond to messages.
Output: Webhook endpoints that receive WhatsApp messages and queue them for processing, with idempotency protection against duplicates.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-webhook-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-webhook-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: WhatsApp webhook types, signature validation, and payload parser</name>
  <files>
    src/webhook/types.ts
    src/webhook/signature.ts
    src/webhook/parser.ts
  </files>
  <action>
    Create src/webhook/types.ts:
    - Define TypeScript types for WhatsApp Cloud API webhook payloads:
      - `WhatsAppWebhookPayload`: Top-level `{ object, entry[] }`
      - `WebhookEntry`: `{ id, changes[] }`
      - `WebhookChange`: `{ value, field }`
      - `WebhookValue`: `{ messaging_product, metadata, contacts?, messages?, statuses? }`
      - `WebhookMessage`: `{ id, from, timestamp, type, text?: { body: string } }`
      - `WebhookContact`: `{ profile: { name: string }, wa_id: string }`
    - Use Zod schemas to validate incoming payloads at runtime (not just TypeScript types)
    - Export both the Zod schemas and inferred TypeScript types
    - Handle the deeply nested structure: `entry[0].changes[0].value.messages[0]`

    Create src/webhook/signature.ts:
    - Implement `validateWebhookSignature(rawBody: Buffer, signatureHeader: string | undefined, appSecret: string): boolean`
    - Compute HMAC-SHA256 of the raw body buffer using the app secret
    - Compare using `crypto.timingSafeEqual` to prevent timing attacks (NOT string comparison)
    - Handle missing signature header (return false)
    - Handle mismatched buffer lengths (return false)
    - Use `node:crypto` imports (ESM)
    - See research Pattern 2 for reference implementation

    Create src/webhook/parser.ts:
    - Implement `extractMessages(payload: WhatsAppWebhookPayload): ParsedMessage[]`
    - ParsedMessage type: `{ messageId: string, from: string, timestamp: string, type: string, text: string | null, senderName: string | null }`
    - Safely traverse the nested payload structure with null checks at every level
    - Skip entries where `messages` is undefined (these are status updates -- see Pitfall 6)
    - Validate each message with Zod before including in results
    - Log warnings for unexpected message types (non-text) but don't throw
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm all types compile.
    Create a quick inline test: parse a sample WhatsApp webhook payload JSON through extractMessages and verify it returns the expected ParsedMessage array.
  </verify>
  <done>
    signature.ts validates HMAC-SHA256 with timing-safe comparison.
    parser.ts extracts messages from nested WhatsApp payloads, skipping status updates.
    types.ts defines Zod schemas and TypeScript types for all WhatsApp webhook structures.
    All files compile with no TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: BullMQ queue setup, idempotency store, and webhook routes</name>
  <files>
    src/queue/types.ts
    src/queue/connection.ts
    src/queue/producer.ts
    src/state/idempotency.ts
    src/webhook/routes.ts
  </files>
  <action>
    Create src/queue/types.ts:
    - Define `MessageJobData` interface: `{ messageId: string, from: string, timestamp: string, type: string, text: string | null, senderName: string | null }`
    - Define `MessageJobResult` interface: `{ success: boolean, responseText?: string, error?: string }`

    Create src/queue/connection.ts:
    - `createQueueConnection(redisUrl: string)`: IORedis instance with `maxRetriesPerRequest: 20` (fail-fast for producers)
    - `createWorkerConnection(redisUrl: string)`: IORedis instance with `maxRetriesPerRequest: null` (CRITICAL for BullMQ workers -- see Pitfall 3)
    - Both connections should have `enableReadyCheck: false` for faster startup
    - Log connection events (connect, error, close) via logger

    Create src/queue/producer.ts:
    - `createMessageQueue(connection: IORedis): Queue<MessageJobData>`
    - Queue name from constants (QUEUE_NAME)
    - Default job options: attempts: 3, exponential backoff starting at 1000ms, removeOnComplete: { count: 1000 }, removeOnFail: { count: 5000 }
    - Export the function (not a singleton -- the caller provides the connection)

    Create src/state/idempotency.ts:
    - `IdempotencyStore` class with constructor accepting IORedis instance
    - `isProcessed(messageId: string): Promise<boolean>` -- checks Redis key `processed:{messageId}`
    - `markProcessed(messageId: string): Promise<void>` -- sets Redis key with TTL from constants (PROCESSED_MESSAGE_TTL = 7 days)
    - This prevents duplicate processing when WhatsApp retries webhook delivery

    Create src/webhook/routes.ts:
    - Implement as a Fastify plugin: `async function webhookRoutes(fastify: FastifyInstance)`
    - GET /webhook: WhatsApp verification endpoint
      - Reads hub.mode, hub.verify_token, hub.challenge from query params
      - Returns challenge as plain text if mode === 'subscribe' and token matches WHATSAPP_WEBHOOK_VERIFY_TOKEN
      - Returns 403 if verification fails
    - POST /webhook: Message receive endpoint
      - Step 1: Get raw body from `(request as any).rawBody` (attached by custom content-type parser in index.ts)
      - Step 2: Validate signature via validateWebhookSignature. Return 401 on failure.
      - Step 3: Return `reply.code(200).send('OK')` IMMEDIATELY (before any processing -- see Pattern 3)
      - Step 4: Parse payload with extractMessages
      - Step 5: For each message, check idempotency (isProcessed). If already processed, skip and log.
      - Step 6: Mark message as processed in idempotency store
      - Step 7: Enqueue to BullMQ via messageQueue.add('process-message', jobData)
      - Wrap steps 4-7 in try/catch that logs errors but never throws (response already sent)
    - The route plugin needs access to: messageQueue (Queue instance), idempotencyStore (IdempotencyStore instance), config (validated env)
    - Use Fastify's `decorate` or pass dependencies via plugin options
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm all types compile.
    Verify that webhook/routes.ts imports signature, parser, queue/producer, and state/idempotency correctly.
    Check that the POST handler calls reply.send BEFORE any async processing (look at code flow).
  </verify>
  <done>
    GET /webhook returns challenge for WhatsApp verification.
    POST /webhook validates signature, returns 200 immediately, then enqueues messages.
    BullMQ queue is configured with retry logic and separate producer/worker Redis connections.
    IdempotencyStore prevents duplicate message processing via Redis.
    Status update webhooks are silently acknowledged (no processing).
    All files compile with no TypeScript errors.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- GET /webhook endpoint properly validates verify_token and returns challenge
- POST /webhook validates HMAC signature before processing
- POST /webhook returns 200 before async processing begins
- BullMQ worker connection uses maxRetriesPerRequest: null
- Idempotency check prevents duplicate message enqueueing
</verification>

<success_criteria>
- WhatsApp webhook verification endpoint works correctly (GET /webhook)
- Webhook POST validates signatures with timing-safe comparison
- Messages are enqueued to BullMQ within milliseconds of webhook receipt
- Duplicate messages are detected and skipped via Redis idempotency
- Status update webhooks (sent/delivered/read) are handled without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-webhook-infrastructure/01-02-SUMMARY.md`
</output>

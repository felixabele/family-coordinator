---
phase: 04-advanced-features
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/signal/listener.ts
  - src/calendar/conflicts.ts
  - src/config/constants.ts
autonomous: true

must_haves:
  truths:
    - "Bot detects scheduling conflicts and warns user before creating events"
    - "Conflict warning asks 'Trotzdem erstellen?' and user can confirm or cancel"
    - "All-day events do not trigger conflict warnings"
    - "Recurring event creation shows pattern + next 3 dates in confirmation"
    - "Recurring event deletion asks 'Nur dieses oder alle zuk√ºnftigen?'"
    - "Help text includes recurring events and conflict detection features"
  artifacts:
    - path: "src/calendar/conflicts.ts"
      provides: "Conflict detection by querying overlapping events"
      exports: ["findConflicts"]
    - path: "src/signal/listener.ts"
      provides: "Updated pipeline with conflict detection and recurring event handling"
      contains: "findConflicts"
  key_links:
    - from: "src/signal/listener.ts"
      to: "src/calendar/conflicts.ts"
      via: "findConflicts called before event creation"
      pattern: "findConflicts"
    - from: "src/signal/listener.ts"
      to: "src/calendar/operations.ts"
      via: "createRecurringEvent for recurring events"
      pattern: "createRecurringEvent"
    - from: "src/signal/listener.ts"
      to: "src/calendar/recurring.ts"
      via: "trimRecurringEvent for 'alle zuk√ºnftigen' deletion"
      pattern: "trimRecurringEvent"
---

<objective>
Wire conflict detection and recurring event handling into the message processing pipeline.

Purpose: Completes Phase 4 by integrating advanced features into the live application ‚Äî users experience conflict warnings, recurring event creation with confirmation, and recurring event deletion with scope selection.

Output: Fully integrated advanced features ‚Äî conflict detection before event creation, recurring event CRUD with proper UX flows.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-features/04-RESEARCH.md
@.planning/phases/04-advanced-features/04-01-SUMMARY.md

@src/signal/listener.ts
@src/index.ts
@src/config/constants.ts
@src/calendar/operations.ts
@src/calendar/types.ts
@src/calendar/recurring.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conflict detection module and update help text</name>
  <files>
    src/calendar/conflicts.ts
    src/config/constants.ts
  </files>
  <action>
**1. Create conflict detection (src/calendar/conflicts.ts):**

Create new file with `findConflicts` function:

```typescript
export async function findConflicts(
  client: CalendarClient,
  newEvent: { start: string; end: string }, // ISO datetime strings
): Promise<CalendarEvent[]>;
```

Implementation:

- Parse `newEvent.start` and `newEvent.end` as Luxon DateTime objects
- Calculate day boundaries: `dayStart = newStart.startOf('day')`, `dayEnd = newStart.endOf('day')`
- Query Google Calendar with `events.list`:
  - `timeMin: dayStart.toISO()`
  - `timeMax: dayEnd.toISO()`
  - `singleEvents: true` (CRITICAL: expand recurring events into instances ‚Äî see research pitfall 3)
  - `orderBy: 'startTime'`
- Filter results:
  - Skip all-day events (`event.start?.date` exists) ‚Äî per user decision, all-day events do NOT trigger conflicts
  - For each timed event, check overlap: `newStart < eventEnd && newEnd > eventStart`
- Map matching events to `CalendarEvent[]` (same mapping pattern as listEvents)
- Return conflicting events array (empty if no conflicts)
- Use same error handling pattern as other calendar operations (CalendarError)

Import CalendarClient from `./client.js`, CalendarEvent/CalendarError from `./types.js`, DateTime from luxon.

**2. Update HELP_TEXT (src/config/constants.ts):**

Update `HELP_TEXT` to include new features:

```typescript
export const HELP_TEXT = [
  "Ich bin dein Familienkalender-Bot! Das kann ich f√ºr dich tun:",
  "",
  'üìÖ Termine anzeigen ‚Äî z.B. "Was steht heute an?" oder "Termine diese Woche"',
  '‚ûï Termine erstellen ‚Äî z.B. "Zahnarzt am Montag um 10 Uhr"',
  'üîÑ Wiederkehrende Termine ‚Äî z.B. "Jeden Dienstag Fu√üball um 16 Uhr"',
  '‚úèÔ∏è Termine √§ndern ‚Äî z.B. "Verschieb den Zahnarzt auf Donnerstag"',
  '‚ùå Termine l√∂schen ‚Äî z.B. "L√∂sche den Zahnarzt-Termin"',
  "",
  'Schreib "abbrechen" um neu zu starten.',
].join("\n");
```

  </action>
  <verify>
Run `npx tsc --noEmit` ‚Äî zero errors. Verify src/calendar/conflicts.ts exists with findConflicts export. Verify `grep "singleEvents: true" src/calendar/conflicts.ts` confirms recurring event expansion. Verify `grep "Wiederkehrende" src/config/constants.ts` shows updated help text.
  </verify>
  <done>
Conflict detection module created with overlap checking, all-day event exclusion, and recurring event instance expansion. Help text updated with recurring events. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate conflict detection and recurring events into pipeline</name>
  <files>
    src/signal/listener.ts
  </files>
  <action>
**1. Update message listener (src/signal/listener.ts):**

Add imports:

- `findConflicts` from `../calendar/conflicts.js`
- `createRecurringEvent` from `../calendar/operations.js` (already imported file, add to existing import)
- `CreateRecurringEventInput` from `../calendar/types.js`
- `calculateNextOccurrences` from `../calendar/recurring.js`
- `trimRecurringEvent` from `../calendar/recurring.js`

**Modify `create_event` case in `handleIntent`:**

Before creating the event, add conflict detection:

a. Calculate start/end DateTimes for the new event using `createEventDateTime` and `createEventEndDateTime`
b. Call `findConflicts(deps.calendarClient, { start: startDt.dateTime, end: endDt.dateTime })`
c. If conflicts found:

- Format conflict list in German: each conflict as `"${summary} um ${HH:mm} Uhr"`
- Return warning message: `"Achtung: √úberschneidung mit ${conflictList}. Trotzdem erstellen?"`
- Save pending event in conversation state using `deps.conversationStore.saveState()` with:
  - `currentIntent: 'awaiting_conflict_confirmation'`
  - `pendingEntities: { ...eventInput, recurrence: intent.entities.recurrence }` (so we can create it after confirmation)
- Return the warning (don't create event yet)

After "Trotzdem erstellen?" flow ‚Äî add handler for conflict confirmation:

At the beginning of the `handleIntent` function (before the switch), check if there's a pending conflict confirmation in conversation state:

- If `currentIntent === 'awaiting_conflict_confirmation'` and user says something affirmative ("ja", "ok", "trotzdem", "yes", "klar", "mach"):
  - Retrieve pending event from `pendingEntities`
  - Create the event (regular or recurring depending on presence of recurrence data)
  - Clear conversation state
  - Return confirmation message
- If negative ("nein", "no", "abbrechen", "doch nicht"):
  - Clear conversation state
  - Return "Alles klar, Termin wurde nicht erstellt."

**Modify event creation to handle recurring:**

In the `create_event` case (after conflict check passes or user confirms):

- Check if `intent.entities.recurrence` exists
- If YES: call `createRecurringEvent(deps.calendarClient, recurringInput)` which returns `{ event, nextOccurrences }`
  - Build confirmation with frequency pattern in German:
    - DAILY ‚Üí "t√§glich"
    - WEEKLY with day ‚Üí "jeden {Wochentag}" (map day_of_week to German: MO‚ÜíMontag, TU‚ÜíDienstag, etc.)
    - MONTHLY ‚Üí "monatlich"
  - Format: `"${title} ${pattern} um ${time} erstellt. N√§chste: ${nextOccurrences.join(', ')}"`
  - If end_date present, append: `" Endet: ${formattedEndDate}"`
- If NO: use existing `createEvent` (unchanged)

**Modify `delete_event` case for recurring events:**

After finding a single event, check if the event has recurrence data (check `event.recurringEventId` ‚Äî added in Plan 04-01).

When deleting a recurring event instance:

- Ask: `"Das ist ein wiederkehrender Termin. Nur dieses Mal oder alle zuk√ºnftigen l√∂schen?\n1) Nur dieses Mal\n2) Alle zuk√ºnftigen"`
- Save in conversation state: `currentIntent: 'awaiting_delete_scope'`, `pendingEntities: { eventId, recurringEventId }`
- Return the question

Add handler at beginning of handleIntent (alongside conflict confirmation handler):

- If `currentIntent === 'awaiting_delete_scope'`:
  - Parse user response for "1", "dieses", "nur" ‚Üí delete single instance
  - Parse user response for "2", "alle", "zuk√ºnftige" ‚Üí delete all future
  - For single instance: call `deleteEvent(deps.calendarClient, instanceEventId)` (deleting a single instance of a recurring event in Google Calendar creates an exception)
  - For all future (per locked user decision ‚Äî "alle zuk√ºnftigen" means future only, preserving past occurrences):
    - Call `trimRecurringEvent(deps.calendarClient, recurringEventId, instanceStartDate, deps.timezone)` (imported from `../calendar/recurring.js`, added in Plan 04-01)
    - This updates the original recurring event's RRULE to set `UNTIL` to the day before the selected instance, so past occurrences are preserved and only future ones are removed
    - Return: `"Alle zuk√ºnftigen Termine ab ${instanceDate} gel√∂scht."`
  - Clear conversation state
  - Return appropriate German confirmation

    </action>
    <verify>
  Run `npx tsc --noEmit` ‚Äî zero errors. Verify `grep "findConflicts" src/signal/listener.ts` shows conflict check. Verify `grep "Trotzdem erstellen" src/signal/listener.ts` shows conflict warning. Verify `grep "awaiting_conflict_confirmation" src/signal/listener.ts` shows confirmation flow. Verify `grep "createRecurringEvent" src/signal/listener.ts` shows recurring event creation. Verify `grep "N√§chste:" src/signal/listener.ts` shows next occurrences in confirmation. Verify `grep "wiederkehrender Termin" src/signal/listener.ts` shows recurring delete prompt. Verify `grep "trimRecurringEvent" src/signal/listener.ts` shows RRULE trimming.
    </verify>
    <done>
  Conflict detection integrated before event creation with German warning and confirmation flow. Recurring event creation with frequency confirmation and next 3 occurrences shown. Recurring event deletion asks scope question (this instance vs all future) with RRULE trimming for future-only deletion. TypeScript compiles cleanly.
    </done>
  </task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Full conflict detection flow:
   - `grep "findConflicts" src/signal/listener.ts` shows pre-creation check
   - `grep "Trotzdem erstellen" src/signal/listener.ts` shows German warning
   - `grep "awaiting_conflict_confirmation" src/signal/listener.ts` shows state tracking
3. Recurring event creation flow:
   - `grep "createRecurringEvent" src/signal/listener.ts` shows recurring creation
   - `grep "N√§chste:" src/signal/listener.ts` shows occurrence display
   - `grep "t√§glich\|jeden\|monatlich" src/signal/listener.ts` shows German frequency labels
4. Recurring event deletion flow:
   - `grep "wiederkehrender Termin" src/signal/listener.ts` shows scope question
   - `grep "awaiting_delete_scope" src/signal/listener.ts` shows state tracking
   - `grep "trimRecurringEvent" src/signal/listener.ts` shows RRULE trimming for "alle zuk√ºnftigen"
5. Updated help text:
   - `grep "Wiederkehrende" src/config/constants.ts` shows new feature in help
6. CalendarEvent recurringEventId (from Plan 04-01):
   - `grep "recurringEventId" src/calendar/types.ts` confirms field exists (from Plan 04-01)
   - `grep "recurringEventId" src/signal/listener.ts` confirms field is used for recurring event detection
</verification>

<success_criteria>

- Conflict detection queries same-day events with `singleEvents: true` (recurring instances expanded)
- All-day events excluded from conflict detection (per user decision)
- Conflict warning in German with "Trotzdem erstellen?" prompt
- User can confirm or cancel after conflict warning
- Recurring event creation calls createRecurringEvent and shows pattern + next 3 dates
- German frequency labels used (t√§glich, jeden Dienstag, monatlich)
- End date shown in confirmation if specified
- Recurring event deletion asks "Nur dieses oder alle zuk√ºnftigen?"
- "Alle zuk√ºnftigen" trims RRULE UNTIL (preserving past instances), not deleting entire event
- Help text updated with recurring events and conflict detection features
- All TypeScript compiles cleanly with zero errors
  </success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-features/04-03-SUMMARY.md`
</output>

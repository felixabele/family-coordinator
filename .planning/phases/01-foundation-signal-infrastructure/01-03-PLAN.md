---
phase: 01-foundation-signal-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/index.ts
  - src/state/idempotency.ts
  - src/db/migrations/002_idempotency.sql
  - .env.example
autonomous: false

must_haves:
  truths:
    - "Bot starts as a daemon process that listens for Signal messages"
    - "Bot gracefully shuts down on SIGTERM/SIGINT (closes Signal client, DB pool)"
    - "Bot logs startup with configuration details"
    - "Old WhatsApp/BullMQ/Fastify code is removed from the project"
    - ".env.example documents all required environment variables"
  artifacts:
    - path: "src/index.ts"
      provides: "Application entry point for Signal daemon"
      contains: "startListening"
      min_lines: 50
    - path: ".env.example"
      provides: "Environment variable documentation"
      contains: "SIGNAL_PHONE_NUMBER"
  key_links:
    - from: "src/index.ts"
      to: "src/signal/client.ts"
      via: "createSignalClient call"
      pattern: "createSignalClient"
    - from: "src/index.ts"
      to: "src/signal/listener.ts"
      via: "setupMessageListener call"
      pattern: "setupMessageListener"
    - from: "src/index.ts"
      to: "src/config/env.ts"
      via: "validateEnv call"
      pattern: "validateEnv"
    - from: "src/index.ts"
      to: "src/db/pool.ts"
      via: "pool and closePool for DB lifecycle"
      pattern: "pool|closePool"
---

<objective>
Rewrite the application entry point as a Signal daemon, remove all obsolete WhatsApp code, and create .env.example documentation.

Purpose: This is the final wiring plan that makes the bot actually run. It replaces the Fastify/BullMQ entry point with a Signal daemon that starts listening for messages on boot. It also cleans up all dead WhatsApp/webhook/queue code and provides a checkpoint for the user to verify the bot works end-to-end.

Output: Working application entry point, clean codebase with no dead WhatsApp code, .env.example for setup guidance.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-signal-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-signal-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-signal-infrastructure/01-02-SUMMARY.md

@src/index.ts
@src/signal/client.ts
@src/signal/listener.ts
@src/signal/sender.ts
@src/db/pool.ts
@src/config/env.ts
@src/state/idempotency.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite entry point, migrate idempotency to PostgreSQL, and clean up dead code</name>
  <files>
    src/index.ts
    src/state/idempotency.ts
    src/db/migrations/002_idempotency.sql
    .env.example
  </files>
  <action>
    **1. Migrate IdempotencyStore from Redis to PostgreSQL:**

    Create `src/db/migrations/002_idempotency.sql`:
    ```sql
    CREATE TABLE IF NOT EXISTS processed_messages (
      message_id TEXT PRIMARY KEY,
      processed_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE INDEX idx_processed_messages_processed_at ON processed_messages (processed_at);
    ```

    Update `src/state/idempotency.ts`:
    - Change constructor to accept `Pool` from `pg` instead of `Redis` from `ioredis`
    - `isProcessed(messageId)`: Use `SELECT 1 FROM processed_messages WHERE message_id = $1` and return `result.rows.length > 0`
    - `markProcessed(messageId)`: Use `INSERT INTO processed_messages (message_id) VALUES ($1) ON CONFLICT (message_id) DO NOTHING`
    - Add `cleanup()` method: `DELETE FROM processed_messages WHERE processed_at < NOW() - INTERVAL '7 days'`
    - Update imports: remove `ioredis`, add `pg` Pool type
    - Update JSDoc comments from WhatsApp/Redis references to Signal/PostgreSQL
    - Keep the same interface (isProcessed, markProcessed) so listener.ts does not need changes

    **2. Rewrite src/index.ts as Signal daemon entry point:**

    The new entry point should follow this structure:

    ```
    start() function:
      1. Validate environment (validateEnv)
      2. Log startup with config details (NODE_ENV, LOG_LEVEL, SIGNAL_PHONE_NUMBER masked)
      3. Create service instances:
         - createSignalClient(config.SIGNAL_PHONE_NUMBER)
         - createAnthropicClient(config.ANTHROPIC_API_KEY)
         - new ConversationStore(pool)
         - new IdempotencyStore(pool)
      4. Run idempotency cleanup on startup (idempotencyStore.cleanup())
      5. Setup message listener (setupMessageListener with all deps)
      6. Start listening (signalClient.startListening())
      7. Log "Signal bot started, listening for messages..."
      8. Register graceful shutdown handlers for SIGTERM and SIGINT
    ```

    **Graceful shutdown handler:**
    ```
    shutdown(signal):
      1. Log "Received {signal}, shutting down..."
      2. Stop Signal client (signalClient.stopListening())
      3. Close PostgreSQL pool (closePool())
      4. Log "Graceful shutdown complete"
      5. process.exit(0)
    ```

    **Imports needed:**
    - `validateEnv` from `./config/env.js`
    - `logger` from `./utils/logger.js`
    - `pool, closePool` from `./db/pool.js`
    - `createSignalClient` from `./signal/client.js`
    - `setupMessageListener` from `./signal/listener.js`
    - `createAnthropicClient` from `./llm/client.js`
    - `ConversationStore` from `./state/conversation.js`
    - `IdempotencyStore` from `./state/idempotency.js`

    **Do NOT import or reference:** Fastify, BullMQ, Redis, webhook routes, queue modules, WhatsApp sender.

    **3. Delete obsolete WhatsApp code:**
    - Delete entire `src/webhook/` directory (parser.ts, routes.ts, signature.ts, types.ts)
    - Delete entire `src/queue/` directory (connection.ts, consumer.ts, producer.ts, types.ts)
    - Delete entire `src/messaging/` directory (sender.ts, templates.ts, types.ts)

    **4. Create .env.example:**
    ```
    # Signal Configuration
    SIGNAL_PHONE_NUMBER=+12025551234

    # Anthropic API
    ANTHROPIC_API_KEY=sk-ant-your-key-here

    # Database
    DATABASE_URL=postgresql://user:password@localhost:5432/family_coordinator

    # Application
    NODE_ENV=development
    LOG_LEVEL=info
    ```

    Include comments explaining each variable. Keep it concise.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify full project compiles.
    Verify old directories are deleted: `ls src/webhook/ 2>&1` should show "No such file or directory".
    Verify old directories are deleted: `ls src/queue/ 2>&1` should show "No such file or directory".
    Verify old directories are deleted: `ls src/messaging/ 2>&1` should show "No such file or directory".
    Verify .env.example exists: `ls .env.example`
    Verify no dead imports: `grep -r "fastify\|bullmq\|ioredis\|webhook\|queue/\|messaging/" src/ --include="*.ts" | grep -v node_modules` should return nothing.
    Verify migration exists: `ls src/db/migrations/002_idempotency.sql`
    Run `npx tsc --noEmit` -- no errors.
  </verify>
  <done>
    src/index.ts launches Signal daemon with all components wired together.
    Graceful shutdown handles SIGTERM/SIGINT.
    IdempotencyStore uses PostgreSQL Pool instead of Redis.
    Migration 002_idempotency.sql creates processed_messages table.
    src/webhook/, src/queue/, src/messaging/ directories are deleted.
    No dead imports or references to WhatsApp/Fastify/BullMQ/Redis in src/.
    .env.example documents all required environment variables.
    Full TypeScript compilation passes with zero errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify Signal bot starts and processes messages</name>
  <files>src/index.ts</files>
  <action>
    This is a human verification checkpoint. No code changes needed -- just verify the bot works end-to-end.

    The complete Signal bot daemon has been built with:
    - Signal message receiving via signal-cli/signal-sdk
    - Idempotency-checked message processing (PostgreSQL-backed)
    - Claude LLM intent extraction
    - Conversation state management
    - Signal message responses
    - Graceful shutdown

    **Prerequisites for verification:**
    1. Ensure signal-cli is installed and registered with your phone number (one-time setup)
    2. Copy .env.example to .env and fill in real values
    3. Ensure PostgreSQL is running and DATABASE_URL is correct
    4. Run migrations: `npm run migrate`

    **Test the bot:**
    1. Start the bot: `npm run dev`
    2. Verify startup logs show "Signal bot started, listening for messages..."
    3. From another Signal account, send a message to the bot's number:
       - Send "Hello" -- should get a greeting response
       - Send "Help" -- should get a help menu response
       - Send "Add dentist appointment Tuesday at 2pm" -- should acknowledge the create_event intent
       - Send "What's on today?" -- should acknowledge the query_events intent
    4. Send the same message twice quickly -- only one response (idempotency working)
    5. Stop the bot with Ctrl+C -- should see graceful shutdown logs

    **If signal-sdk is not functional:**
    The bot may fail to start if signal-sdk doesn't work as expected. In that case, note what error occurs and we will adapt in a gap closure plan.
  </action>
  <verify>User confirms bot starts and processes messages correctly, or reports issues for gap closure.</verify>
  <done>User has typed "approved" confirming the bot receives Signal messages, extracts intent via Claude, and responds correctly. Or user has reported issues that will be addressed in a gap closure plan.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors across entire project
2. No references to WhatsApp, Fastify, BullMQ, Redis, webhook, or queue in src/
3. Bot starts with `npm run dev` and logs startup information
4. Bot receives Signal messages and responds with intent acknowledgment
5. Duplicate messages are not processed twice
6. Ctrl+C triggers graceful shutdown
</verification>

<success_criteria>
- Application entry point starts Signal daemon and listens for messages
- All WhatsApp/webhook/queue dead code is removed
- IdempotencyStore migrated from Redis to PostgreSQL
- Bot processes messages end-to-end: receive -> deduplicate -> state -> LLM -> respond
- Graceful shutdown works for SIGTERM and SIGINT
- .env.example documents all required variables
- User confirms bot works via checkpoint
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-signal-infrastructure/01-03-SUMMARY.md`
</output>

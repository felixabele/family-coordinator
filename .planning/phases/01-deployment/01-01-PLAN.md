---
phase: 01-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - .dockerignore
  - docker-compose.production.yml
  - src/config/secrets.ts
  - src/health.ts
  - src/config/env.ts
autonomous: true

must_haves:
  truths:
    - "Application builds into a working Docker image with no build step (native TS stripping)"
    - "Docker Compose starts app, postgres, and pg-backup services with health checks"
    - "Secrets are read from files (Docker secrets pattern) with fallback to env vars"
    - "Health check HTTP endpoint responds on /health with database and signal status"
  artifacts:
    - path: "Dockerfile"
      provides: "Production container image definition"
      contains: "node:22-alpine"
    - path: ".dockerignore"
      provides: "Build context exclusions"
      contains: "node_modules"
    - path: "docker-compose.production.yml"
      provides: "Production multi-service orchestration"
      contains: "pg-backup"
    - path: "src/config/secrets.ts"
      provides: "Secret reading from files with env var fallback"
      exports: ["getSecret"]
    - path: "src/health.ts"
      provides: "Health check HTTP server"
      exports: ["startHealthServer", "stopHealthServer"]
  key_links:
    - from: "src/config/secrets.ts"
      to: "src/config/env.ts"
      via: "getSecret used in env validation for production"
      pattern: "getSecret"
    - from: "docker-compose.production.yml"
      to: "Dockerfile"
      via: "build context reference"
      pattern: "build:"
    - from: "src/health.ts"
      to: "src/db/pool.ts"
      via: "database health check query"
      pattern: "pool.query"
---

<objective>
Containerize the Family Coordinator application for production deployment with Docker, add secrets management for secure credential handling, and create a health check HTTP endpoint for monitoring.

Purpose: Enable consistent, reproducible deployments on any VPS with proper secrets isolation and production monitoring.
Output: Dockerfile, production Docker Compose, secrets utility, health check endpoint.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-deployment/01-RESEARCH.md

@src/index.ts
@src/config/env.ts
@src/db/pool.ts
@src/utils/logger.ts
@src/signal/client.ts
@package.json
@docker-compose.yml
@.env.example
@.gitignore
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dockerfile, .dockerignore, and secrets utility</name>
  <files>Dockerfile, .dockerignore, src/config/secrets.ts, src/config/env.ts</files>
  <action>
  1. Create `Dockerfile` for production:
     - Base image: `node:22-alpine`
     - NO multi-stage build needed (no build step — Node.js 22 runs TypeScript natively with --experimental-strip-types)
     - Install `tini` for proper signal handling (`apk add --no-cache tini`)
     - Create non-root user `nodejs` (uid 1001)
     - WORKDIR /app
     - Copy package*.json, run `npm ci --omit=dev` (production dependencies only)
     - Copy `src/` directory and `family-members.example.json`
     - Do NOT copy .env, keys/, secrets/, family-members.json, signal-cli data (these are mounted at runtime)
     - Create directories for logs: `mkdir -p /app/logs`
     - Set ownership to nodejs user
     - Switch to non-root user
     - EXPOSE 3000 (health check port)
     - ENTRYPOINT ["/sbin/tini", "--"]
     - CMD ["node", "--experimental-strip-types", "src/index.ts"]
     - Note: --env-file is NOT used in Docker — env vars come from Docker Compose environment/secrets

2. Create `.dockerignore`:

   ```
   node_modules
   dist
   .env
   .env.*
   .git
   .gitignore
   .claude
   .planning
   .letta
   .husky
   .DS_Store
   *.log
   keys/
   secrets/
   family-members.json
   scripts/
   README.md
   tsconfig.json
   eslint.config.mjs
   docker-compose.yml
   docker-compose.production.yml
   ```

3. Create `src/config/secrets.ts`:
   - Export function `getSecret(secretName: string): string`
   - Check for `${secretName}_FILE` env var first
   - If found, read file contents with `readFileSync()`, trim whitespace, return value
   - If not found, fall back to `process.env[secretName]`
   - If neither exists, throw Error with descriptive message
   - Import `readFileSync` from `fs`
   - Export function `getSecretOptional(secretName: string): string | undefined` — same logic but returns undefined instead of throwing

4. Update `src/config/env.ts`:
   - Import `getSecret` from `./secrets.js`
   - Modify the env schema to support the `_FILE` suffix pattern for production:
     - Keep the Zod schema as-is for shape validation
     - After Zod validation, apply `getSecret()` to resolve the actual values for: ANTHROPIC_API_KEY, DATABASE_URL, GOOGLE_SERVICE_ACCOUNT_KEY_FILE
     - This means: in development, env vars work directly; in production, `_FILE` suffix reads from Docker secrets
   - Implementation approach: After `envSchema.safeParse(process.env)`, create a resolved config object that calls `getSecret()` for sensitive fields. Use a helper that tries `_FILE` first, then falls back to the direct value already parsed by Zod.
   - Important: SIGNAL_PHONE_NUMBER also needs secret support (it's sensitive)
   - Do NOT break the existing development workflow — `getSecret` falls back to direct env vars seamlessly
     </action>
     <verify>

- `docker build -t family-coordinator .` succeeds
- `docker run --rm family-coordinator node -e "console.log('ok')"` prints "ok"
- `npx tsc --noEmit` passes (secrets.ts and env.ts type-check)
- `npm run start` still works in development (env var fallback)
  </verify>
  <done>
- Dockerfile builds a working image using node:22-alpine with tini, non-root user, and native TS execution
- .dockerignore excludes all sensitive files and development artifacts
- getSecret() reads from file (production) or env var (development) seamlessly
- env.ts resolves secrets via getSecret() without breaking existing development workflow
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create production Docker Compose and health check endpoint</name>
  <files>docker-compose.production.yml, src/health.ts, src/index.ts</files>
  <action>
  1. Create `src/health.ts`:
     - Import `createServer` from `node:http`
     - Import `pool` from `./db/pool.js`
     - Import `logger` from `./utils/logger.js`
     - Export function `startHealthServer(port: number = 3000): http.Server`
       - Creates an HTTP server that responds to GET /health
       - Health check logic:
         - Runs `SELECT 1` on the database pool to verify connectivity
         - Returns JSON: `{ status: "healthy"|"unhealthy", timestamp: ISO string, checks: { database: boolean }, uptime: process.uptime() }`
         - Returns HTTP 200 for healthy, 503 for unhealthy
         - Any other path returns 404
       - Server listens on specified port
       - Log "Health check server started on port {port}"
       - Return the server instance
     - Export function `stopHealthServer(server: http.Server): Promise<void>`
       - Closes the server gracefully
       - Returns a promise that resolves when closed
     - Note: Do NOT check Signal connectivity in health check — signal-sdk doesn't expose a reliable "is connected" method. Database check is sufficient for Docker healthcheck.

2. Update `src/index.ts`:
   - Import `startHealthServer, stopHealthServer` from `./health.js`
   - After step 5 (connect to Signal), start health server: `const healthServer = startHealthServer()`
   - In shutdown handler, add `await stopHealthServer(healthServer)` before closing other resources

3. Create `docker-compose.production.yml`:
   - Version: "3.9" (or omit — modern Compose doesn't need it)
   - Three services: `app`, `postgres`, `pg-backup`

   **app service:**
   - `build: .`
   - `restart: unless-stopped`
   - `depends_on: postgres: condition: service_healthy`
   - `environment:` — only non-sensitive values:
     - `NODE_ENV=production`
     - `LOG_LEVEL=info`
     - `FAMILY_TIMEZONE=Europe/Berlin`
   - `secrets:` — reference all secret names
   - `environment:` — add \_FILE references:
     - `SIGNAL_PHONE_NUMBER_FILE=/run/secrets/signal_phone`
     - `ANTHROPIC_API_KEY_FILE=/run/secrets/anthropic_key`
     - `GOOGLE_SERVICE_ACCOUNT_KEY_FILE=/run/secrets/google_service_account`
     - `GOOGLE_CALENDAR_ID_FILE=/run/secrets/google_calendar_id`
     - `DATABASE_URL_FILE=/run/secrets/database_url`
   - `volumes:`
     - `./data/signal-cli:/home/.local/share/signal-cli` (signal-cli data persistence)
     - `./family-members.json:/app/family-members.json:ro` (family whitelist)
     - `./logs:/app/logs` (application logs)
   - `healthcheck:`
     - `test: ["CMD", "node", "-e", "fetch('http://localhost:3000/health').then(r=>{if(!r.ok)process.exit(1)})"]`
     - `interval: 30s`
     - `timeout: 10s`
     - `retries: 3`
     - `start_period: 60s` (signal-cli needs time to start)
   - `logging:` driver: json-file, max-size: 10m, max-file: 3

   **postgres service:**
   - `image: postgres:16`
   - `restart: unless-stopped`
   - `environment:`
     - `POSTGRES_PASSWORD_FILE=/run/secrets/db_password`
     - `POSTGRES_DB=family_coordinator`
   - `secrets:` — db_password
   - `volumes:` — `./data/postgres:/var/lib/postgresql/data`
   - `healthcheck:`
     - `test: ["CMD-SHELL", "pg_isready -U postgres"]`
     - `interval: 10s`
     - `timeout: 5s`
     - `retries: 5`
   - Do NOT expose port 5432 to host (only accessible within Docker network)

   **pg-backup service:**
   - `image: prodrigestivill/postgres-backup-local`
   - `restart: unless-stopped`
   - `depends_on: postgres`
   - `environment:`
     - `POSTGRES_HOST=postgres`
     - `POSTGRES_DB=family_coordinator`
     - `POSTGRES_USER=postgres`
     - `POSTGRES_PASSWORD_FILE=/run/secrets/db_password`
     - `SCHEDULE=@daily`
     - `BACKUP_KEEP_DAYS=7`
     - `BACKUP_KEEP_WEEKS=4`
     - `BACKUP_KEEP_MONTHS=6`
   - `secrets:` — db_password
   - `volumes:` — `./data/backups:/backups`

   **secrets section:**

   ```yaml
   secrets:
     signal_phone:
       file: ./secrets/signal-phone.txt
     anthropic_key:
       file: ./secrets/anthropic-api-key.txt
     google_service_account:
       file: ./secrets/google-service-account.json
     google_calendar_id:
       file: ./secrets/google-calendar-id.txt
     database_url:
       file: ./secrets/database-url.txt
     db_password:
       file: ./secrets/db-password.txt
   ```

   **networks:** default bridge
   </action>
   <verify>

- `npx tsc --noEmit` passes (health.ts type-checks)
- `docker compose -f docker-compose.production.yml config` validates the Compose file
- Health server starts when app starts (check logs for "Health check server started")
- `curl http://localhost:3000/health` returns JSON with status field (when running locally)
  </verify>
  <done>
- Health check HTTP server responds on GET /health with database connectivity status
- Health server integrates into app lifecycle (start on boot, stop on shutdown)
- Production Docker Compose defines app + postgres + pg-backup with health checks, secrets, and persistent volumes
- Secrets are referenced via \_FILE suffix pattern, never stored in images or compose file
  </done>
  </task>

</tasks>

<verification>
- Docker image builds successfully: `docker build -t family-coordinator .`
- Docker Compose config validates: `docker compose -f docker-compose.production.yml config`
- TypeScript compiles: `npx tsc --noEmit`
- Development workflow unchanged: `npm run start` works with .env file
- Health endpoint functional: GET /health returns JSON with status
- No secrets in Dockerfile or docker-compose.production.yml (only _FILE references)
- .dockerignore excludes all sensitive files
</verification>

<success_criteria>
Application is fully containerized with a production Docker Compose that orchestrates app, database, and backup services. Secrets are securely managed via the \_FILE pattern. A health check endpoint enables production monitoring. The development workflow remains unchanged.
</success_criteria>

<output>
After completion, create `.planning/phases/01-deployment/01-01-SUMMARY.md`
</output>

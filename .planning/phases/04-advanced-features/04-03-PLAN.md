---
phase: 04-advanced-features
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/signal/listener.ts
  - src/calendar/conflicts.ts
  - src/index.ts
  - src/config/constants.ts
  - src/config/family-members.ts
  - .env.example
autonomous: true

must_haves:
  truths:
    - "Bot detects scheduling conflicts and warns user before creating events"
    - "Conflict warning asks 'Trotzdem erstellen?' and user can confirm or cancel"
    - "All-day events do not trigger conflict warnings"
    - "Recurring event creation shows pattern + next 3 dates in confirmation"
    - "Recurring event deletion asks 'Nur dieses oder alle zuk√ºnftigen?'"
    - "Reminder scheduler starts on application boot and shuts down gracefully"
    - "Help text includes recurring events and conflict detection features"
  artifacts:
    - path: "src/calendar/conflicts.ts"
      provides: "Conflict detection by querying overlapping events"
      exports: ["findConflicts"]
    - path: "src/signal/listener.ts"
      provides: "Updated pipeline with conflict detection, recurring event handling, and reminder confirmation flow"
      contains: "findConflicts"
    - path: "src/index.ts"
      provides: "Wired reminder scheduler and Redis connection into application startup"
      contains: "createReminderScheduler"
  key_links:
    - from: "src/signal/listener.ts"
      to: "src/calendar/conflicts.ts"
      via: "findConflicts called before event creation"
      pattern: "findConflicts"
    - from: "src/signal/listener.ts"
      to: "src/calendar/operations.ts"
      via: "createRecurringEvent for recurring events"
      pattern: "createRecurringEvent"
    - from: "src/index.ts"
      to: "src/reminders/scheduler.ts"
      via: "createReminderScheduler and createReminderWorker at startup"
      pattern: "createReminderScheduler"
    - from: "src/index.ts"
      to: "src/config/redis.ts"
      via: "Redis connection creation for BullMQ"
      pattern: "createRedisConnection"
---

<objective>
Wire conflict detection, recurring event handling, and the reminder system into the message processing pipeline and application entry point.

Purpose: Completes Phase 4 by integrating all advanced features into the live application ‚Äî users experience conflict warnings, recurring event creation with confirmation, recurring event deletion with scope selection, and proactive event reminders.

Output: Fully integrated advanced features ‚Äî conflict detection before event creation, recurring event CRUD with proper UX flows, reminder system running on startup.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-features/04-RESEARCH.md
@.planning/phases/04-advanced-features/04-01-SUMMARY.md
@.planning/phases/04-advanced-features/04-02-SUMMARY.md

@src/signal/listener.ts
@src/index.ts
@src/config/constants.ts
@src/config/family-members.ts
@src/calendar/operations.ts
@src/calendar/types.ts
@src/calendar/recurring.ts
@src/reminders/scheduler.ts
@src/reminders/jobs.ts
@src/config/redis.ts
@src/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conflict detection module and add getAllPhoneNumbers to FamilyWhitelist</name>
  <files>
    src/calendar/conflicts.ts
    src/config/family-members.ts
    src/config/constants.ts
  </files>
  <action>
**1. Create conflict detection (src/calendar/conflicts.ts):**

Create new file with `findConflicts` function:

```typescript
export async function findConflicts(
  client: CalendarClient,
  newEvent: { start: string; end: string }, // ISO datetime strings
): Promise<CalendarEvent[]>;
```

Implementation:

- Parse `newEvent.start` and `newEvent.end` as Luxon DateTime objects
- Calculate day boundaries: `dayStart = newStart.startOf('day')`, `dayEnd = newStart.endOf('day')`
- Query Google Calendar with `events.list`:
  - `timeMin: dayStart.toISO()`
  - `timeMax: dayEnd.toISO()`
  - `singleEvents: true` (CRITICAL: expand recurring events into instances ‚Äî see research pitfall 3)
  - `orderBy: 'startTime'`
- Filter results:
  - Skip all-day events (`event.start?.date` exists) ‚Äî per user decision, all-day events do NOT trigger conflicts
  - For each timed event, check overlap: `newStart < eventEnd && newEnd > eventStart`
- Map matching events to `CalendarEvent[]` (same mapping pattern as listEvents)
- Return conflicting events array (empty if no conflicts)
- Use same error handling pattern as other calendar operations (CalendarError)

Import CalendarClient from `./client.js`, CalendarEvent/CalendarError from `./types.js`, DateTime from luxon.

**2. Add getAllPhoneNumbers to FamilyWhitelist (src/config/family-members.ts):**

Add method to `FamilyWhitelist` class:

```typescript
getAllPhoneNumbers(): string[] {
  return Array.from(this.members.keys());
}
```

This is needed by the reminder system to send reminders to all family members.

**3. Update HELP_TEXT (src/config/constants.ts):**

Update `HELP_TEXT` to include new features:

```typescript
export const HELP_TEXT = [
  "Ich bin dein Familienkalender-Bot! Das kann ich f√ºr dich tun:",
  "",
  'üìÖ Termine anzeigen ‚Äî z.B. "Was steht heute an?" oder "Termine diese Woche"',
  '‚ûï Termine erstellen ‚Äî z.B. "Zahnarzt am Montag um 10 Uhr"',
  'üîÑ Wiederkehrende Termine ‚Äî z.B. "Jeden Dienstag Fu√üball um 16 Uhr"',
  '‚úèÔ∏è Termine √§ndern ‚Äî z.B. "Verschieb den Zahnarzt auf Donnerstag"',
  '‚ùå Termine l√∂schen ‚Äî z.B. "L√∂sche den Zahnarzt-Termin"',
  "‚è∞ Erinnerungen ‚Äî Ich erinnere euch automatisch 1 Stunde vor Terminen",
  "",
  'Schreib "abbrechen" um neu zu starten.',
].join("\n");
```

  </action>
  <verify>
Run `npx tsc --noEmit` ‚Äî zero errors. Verify src/calendar/conflicts.ts exists with findConflicts export. Verify `grep "singleEvents: true" src/calendar/conflicts.ts` confirms recurring event expansion. Verify `grep "getAllPhoneNumbers" src/config/family-members.ts` shows new method. Verify `grep "Wiederkehrende" src/config/constants.ts` shows updated help text.
  </verify>
  <done>
Conflict detection module created with overlap checking, all-day event exclusion, and recurring event instance expansion. FamilyWhitelist extended with getAllPhoneNumbers for reminder system. Help text updated with recurring events and reminders. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate conflict detection, recurring events, and reminders into pipeline</name>
  <files>
    src/signal/listener.ts
    src/index.ts
    .env.example
  </files>
  <action>
**1. Update message listener (src/signal/listener.ts):**

Add imports:

- `findConflicts` from `../calendar/conflicts.js`
- `createRecurringEvent` from `../calendar/operations.js` (already imported file, add to existing import)
- `CreateRecurringEventInput` from `../calendar/types.js`
- `calculateNextOccurrences` from `../calendar/recurring.js`

**Modify `create_event` case in `handleIntent`:**

Before creating the event, add conflict detection:

a. Calculate start/end DateTimes for the new event using `createEventDateTime` and `createEventEndDateTime`
b. Call `findConflicts(deps.calendarClient, { start: startDt.dateTime, end: endDt.dateTime })`
c. If conflicts found:

- Format conflict list in German: each conflict as `"${summary} um ${HH:mm} Uhr"`
- Return warning message: `"Achtung: √úberschneidung mit ${conflictList}. Trotzdem erstellen?"`
- Save pending event in conversation state using `deps.conversationStore.saveState()` with:
  - `currentIntent: 'awaiting_conflict_confirmation'`
  - `pendingEntities: { ...eventInput, recurrence: intent.entities.recurrence }` (so we can create it after confirmation)
- Return the warning (don't create event yet)

After "Trotzdem erstellen?" flow ‚Äî add handler for conflict confirmation:

At the beginning of the `handleIntent` function (before the switch), check if there's a pending conflict confirmation in conversation state:

- If `currentIntent === 'awaiting_conflict_confirmation'` and user says something affirmative ("ja", "ok", "trotzdem", "yes", "klar", "mach"):
  - Retrieve pending event from `pendingEntities`
  - Create the event (regular or recurring depending on presence of recurrence data)
  - Clear conversation state
  - Return confirmation message
- If negative ("nein", "no", "abbrechen", "doch nicht"):
  - Clear conversation state
  - Return "Alles klar, Termin wurde nicht erstellt."

**Modify event creation to handle recurring:**

In the `create_event` case (after conflict check passes or user confirms):

- Check if `intent.entities.recurrence` exists
- If YES: call `createRecurringEvent(deps.calendarClient, recurringInput)` which returns `{ event, nextOccurrences }`
  - Build confirmation with frequency pattern in German:
    - DAILY ‚Üí "t√§glich"
    - WEEKLY with day ‚Üí "jeden {Wochentag}" (map day_of_week to German: MO‚ÜíMontag, TU‚ÜíDienstag, etc.)
    - MONTHLY ‚Üí "monatlich"
  - Format: `"${title} ${pattern} um ${time} erstellt. N√§chste: ${nextOccurrences.join(', ')}"`
  - If end_date present, append: `" Endet: ${formattedEndDate}"`
- If NO: use existing `createEvent` (unchanged)

**Modify `delete_event` case for recurring events:**

After finding a single event, check if the event has recurrence data (check if the Google Calendar event response includes `recurringEventId` field ‚Äî for instances of recurring events, the API returns `recurringEventId`).

Note: The CalendarEvent type needs a small extension. Add `recurringEventId?: string` to CalendarEvent type (or check it from the raw response). Since this plan modifies listener.ts but the type is in types.ts (owned by Plan 01), the simplest approach is to check for the field existence on the raw event data. However, for cleanliness, also update CalendarEvent type to include `recurringEventId?: string` and update the event mapping in operations.ts to populate it from `item.recurringEventId`.

When deleting a recurring event instance:

- Ask: `"Das ist ein wiederkehrender Termin. Nur dieses Mal oder alle zuk√ºnftigen l√∂schen?\n1) Nur dieses Mal\n2) Alle zuk√ºnftigen"`
- Save in conversation state: `currentIntent: 'awaiting_delete_scope'`, `pendingEntities: { eventId, recurringEventId }`
- Return the question

Add handler at beginning of handleIntent (alongside conflict confirmation handler):

- If `currentIntent === 'awaiting_delete_scope'`:
  - Parse user response for "1", "dieses", "nur" ‚Üí delete single instance
  - Parse user response for "2", "alle", "zuk√ºnftige" ‚Üí delete all future (trim RRULE approach)
  - For single instance: call `deleteEvent(deps.calendarClient, instanceEventId)` (deleting a single instance of a recurring event in Google Calendar creates an exception)
  - For all future: call `deleteEvent(deps.calendarClient, recurringEventId)` to delete the entire recurring event
    - Note: Full implementation of "trim RRULE to end before this instance + keep past instances" is complex. For simplicity and per user scope (simple patterns), deleting the entire recurring event is acceptable for MVP. The two-step trim approach can be refined later.
  - Clear conversation state
  - Return appropriate German confirmation

**2. Update application entry point (src/index.ts):**

Add imports:

- `createRedisConnection`, `closeRedisConnection` from `./config/redis.js`
- `createReminderScheduler`, `createReminderWorker`, `closeReminderSystem` from `./reminders/scheduler.js`

Between step 4 (idempotency cleanup) and step 5 (Signal connect), add:

```
// 4.5. Setup reminder system
logger.info('Setting up reminder system...');
const redisQueueConn = createRedisConnection(config.REDIS_HOST, config.REDIS_PORT);
const redisWorkerConn = createRedisConnection(config.REDIS_HOST, config.REDIS_PORT);
await redisQueueConn.connect();
await redisWorkerConn.connect();

const { queue: reminderQueue, startChecking } = createReminderScheduler(redisQueueConn);
const reminderWorker = createReminderWorker(redisWorkerConn, {
  calendarClient,
  signalClient,
  pool,
  familyWhitelist,
  timezone: config.FAMILY_TIMEZONE,
});

await startChecking();
logger.info('Reminder system started (checks every 5 minutes)');
```

Update graceful shutdown to close reminder system and Redis:

```
// In shutdown handler, before closing PostgreSQL:
await closeReminderSystem(reminderQueue, reminderWorker);
logger.info('Reminder system stopped');
await closeRedisConnection(redisQueueConn);
await closeRedisConnection(redisWorkerConn);
logger.info('Redis connections closed');
```

**3. Update .env.example:**

Add Redis configuration:

```
# Redis (for BullMQ reminder system)
REDIS_HOST=localhost
REDIS_PORT=6379
```

**4. Update CalendarEvent type and mapping for recurringEventId:**

In `src/calendar/types.ts`, add `recurringEventId?: string` to `CalendarEvent` interface.
In `src/calendar/operations.ts`, update all event mapping code (in listEvents, findEvents, createEvent, updateEvent) to include:

```typescript
recurringEventId: item.recurringEventId || undefined,
```

  </action>
  <verify>
Run `npx tsc --noEmit` ‚Äî zero errors. Verify `grep "findConflicts" src/signal/listener.ts` shows conflict check. Verify `grep "Trotzdem erstellen" src/signal/listener.ts` shows conflict warning. Verify `grep "awaiting_conflict_confirmation" src/signal/listener.ts` shows confirmation flow. Verify `grep "createRecurringEvent" src/signal/listener.ts` shows recurring event creation. Verify `grep "N√§chste:" src/signal/listener.ts` shows next occurrences in confirmation. Verify `grep "wiederkehrender Termin" src/signal/listener.ts` shows recurring delete prompt. Verify `grep "createReminderScheduler" src/index.ts` shows reminder system wiring. Verify `grep "closeReminderSystem" src/index.ts` shows graceful shutdown. Verify `grep "REDIS_HOST" .env.example` shows new env var.
  </verify>
  <done>
Conflict detection integrated before event creation with German warning and confirmation flow. Recurring event creation with frequency confirmation and next 3 occurrences shown. Recurring event deletion asks scope question (this instance vs all future). Reminder system wired into application startup with graceful shutdown. CalendarEvent extended with recurringEventId for recurring event instance detection. .env.example updated with Redis config. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Full conflict detection flow:
   - `grep "findConflicts" src/signal/listener.ts` shows pre-creation check
   - `grep "Trotzdem erstellen" src/signal/listener.ts` shows German warning
   - `grep "awaiting_conflict_confirmation" src/signal/listener.ts` shows state tracking
3. Recurring event creation flow:
   - `grep "createRecurringEvent" src/signal/listener.ts` shows recurring creation
   - `grep "N√§chste:" src/signal/listener.ts` shows occurrence display
   - `grep "t√§glich\|jeden\|monatlich" src/signal/listener.ts` shows German frequency labels
4. Recurring event deletion flow:
   - `grep "wiederkehrender Termin" src/signal/listener.ts` shows scope question
   - `grep "awaiting_delete_scope" src/signal/listener.ts` shows state tracking
5. Reminder system integration:
   - `grep "createReminderScheduler" src/index.ts` shows startup wiring
   - `grep "closeReminderSystem" src/index.ts` shows graceful shutdown
   - `grep "redisQueueConn\|redisWorkerConn" src/index.ts` shows dual Redis connections
6. Updated help text:
   - `grep "Wiederkehrende" src/config/constants.ts` shows new feature in help
   - `grep "Erinnerungen" src/config/constants.ts` shows reminders in help
7. CalendarEvent recurringEventId:
   - `grep "recurringEventId" src/calendar/types.ts` shows extended type
   - `grep "recurringEventId" src/calendar/operations.ts` shows mapping
</verification>

<success_criteria>

- Conflict detection queries same-day events with `singleEvents: true` (recurring instances expanded)
- All-day events excluded from conflict detection (per user decision)
- Conflict warning in German with "Trotzdem erstellen?" prompt
- User can confirm or cancel after conflict warning
- Recurring event creation calls createRecurringEvent and shows pattern + next 3 dates
- German frequency labels used (t√§glich, jeden Dienstag, monatlich)
- End date shown in confirmation if specified
- Recurring event deletion asks "Nur dieses oder alle zuk√ºnftigen?"
- Reminder scheduler starts on boot, checks every 5 minutes
- Dual Redis connections for BullMQ queue and worker
- Graceful shutdown closes reminder system and Redis connections
- .env.example includes REDIS_HOST and REDIS_PORT
- Help text updated with recurring events and reminders features
- All TypeScript compiles cleanly with zero errors
  </success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-features/04-03-SUMMARY.md`
</output>

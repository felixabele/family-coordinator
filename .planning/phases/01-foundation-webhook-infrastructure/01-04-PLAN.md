---
phase: 01-foundation-webhook-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/messaging/types.ts
  - src/messaging/sender.ts
  - src/messaging/templates.ts
  - src/queue/consumer.ts
  - src/index.ts
autonomous: false

must_haves:
  truths:
    - "Worker dequeues messages from BullMQ and processes them through the full pipeline"
    - "Worker loads conversation state, sends message + history to Claude, and gets structured intent"
    - "Worker sends a WhatsApp response based on the extracted intent"
    - "Worker updates conversation state with the new message and intent"
    - "Duplicate messages are skipped at the worker level via idempotency check"
    - "The full pipeline works end-to-end: WhatsApp message in -> Claude intent -> WhatsApp response out"
    - "Fastify server starts with all components wired together and shuts down gracefully"
  artifacts:
    - path: "src/messaging/sender.ts"
      provides: "WhatsApp Cloud API message sending"
      exports: ["sendWhatsAppMessage"]
    - path: "src/messaging/templates.ts"
      provides: "Response message formatting based on intent"
      exports: ["formatIntentResponse"]
    - path: "src/queue/consumer.ts"
      provides: "BullMQ worker that processes messages through the pipeline"
      exports: ["createMessageWorker"]
    - path: "src/index.ts"
      provides: "Application entry point wiring all components together"
      min_lines: 60
  key_links:
    - from: "src/queue/consumer.ts"
      to: "src/llm/intent.ts"
      via: "calls extractIntent for each dequeued message"
      pattern: "extractIntent"
    - from: "src/queue/consumer.ts"
      to: "src/state/conversation.ts"
      via: "loads and saves conversation state per message"
      pattern: "conversationStore\\.(getState|saveState|addToHistory)"
    - from: "src/queue/consumer.ts"
      to: "src/messaging/sender.ts"
      via: "sends WhatsApp response after processing"
      pattern: "sendWhatsAppMessage"
    - from: "src/index.ts"
      to: "src/webhook/routes.ts"
      via: "registers webhook routes with Fastify"
      pattern: "fastify\\.register.*webhookRoutes"
    - from: "src/index.ts"
      to: "src/queue/consumer.ts"
      via: "creates and starts the BullMQ worker"
      pattern: "createMessageWorker"
    - from: "src/messaging/sender.ts"
      to: "WhatsApp Cloud API"
      via: "fetch POST to graph.facebook.com"
      pattern: "graph\\.facebook\\.com"
---

<objective>
Wire all components into the complete message processing pipeline: BullMQ worker processes queued messages through Claude intent extraction, formats responses, sends via WhatsApp, and updates conversation state. Create the main entry point that bootstraps the entire application.

Purpose: This plan connects everything built in Plans 01-03 into a working end-to-end pipeline. Without this, the individual components are isolated and non-functional. This is the final assembly.
Output: Working application that receives WhatsApp messages, understands them via Claude, and responds conversationally.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-webhook-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-webhook-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-webhook-infrastructure/01-02-SUMMARY.md
@.planning/phases/01-foundation-webhook-infrastructure/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: WhatsApp message sender, response templates, and BullMQ worker</name>
  <files>
    src/messaging/types.ts
    src/messaging/sender.ts
    src/messaging/templates.ts
    src/queue/consumer.ts
  </files>
  <action>
    Create src/messaging/types.ts:
    - Define `WhatsAppSendMessagePayload`: `{ messaging_product: 'whatsapp', to: string, type: 'text', text: { body: string } }`
    - Define `WhatsAppApiResponse`: `{ messages: Array<{ id: string }> }` (success response)
    - Define `WhatsAppApiError`: `{ error: { message: string, type: string, code: number } }`

    Create src/messaging/sender.ts:
    - Implement `sendWhatsAppMessage(phoneNumberId: string, accessToken: string, to: string, text: string): Promise<void>`
    - POST to `https://graph.facebook.com/v21.0/${phoneNumberId}/messages` (use WHATSAPP_API_VERSION from constants)
    - Set Authorization: Bearer ${accessToken} header
    - Body: `{ messaging_product: 'whatsapp', to, type: 'text', text: { body: text } }`
    - Use native fetch (Node 22 built-in, no axios needed)
    - On non-2xx response: parse error body, throw WhatsAppApiError with details
    - Log the response (message ID) at info level and errors at error level

    Create src/messaging/templates.ts:
    - Implement `formatIntentResponse(intent: CalendarIntent): string`
    - Generate human-friendly response text based on intent type:
      - 'greeting': Friendly welcome message explaining the bot can help with calendar tasks
      - 'help': List of things the bot can do (view events, add events, edit, delete)
      - 'create_event': Acknowledge the event details detected, confirm what will be created (Phase 2 will actually create). For now: "I understood you want to add [title] on [date] at [time]. Calendar integration coming soon!"
      - 'query_events': Acknowledge the query. For now: "I understood you want to check events for [date]. Calendar integration coming soon!"
      - 'update_event': Acknowledge the edit request. For now: "I understood you want to update [title]. Calendar integration coming soon!"
      - 'delete_event': Acknowledge the delete request. For now: "I understood you want to delete [title]. Calendar integration coming soon!"
      - 'unclear': Use the clarification_needed text from the intent, or a generic "I didn't quite understand. Could you rephrase?"
    - These are Phase 1 placeholder responses. Phase 2 will replace them with actual calendar operations.

    Create src/queue/consumer.ts:
    - Implement `createMessageWorker(workerConnection: IORedis, deps: WorkerDependencies): Worker<MessageJobData>`
    - WorkerDependencies type: `{ anthropicClient: Anthropic, conversationStore: ConversationStore, idempotencyStore: IdempotencyStore, config: Env, logger: Logger }`
    - The worker processor function for each job:
      1. Extract messageId, from, text, senderName from job.data
      2. Check idempotency: if already processed, log and return early (belt-and-suspenders with the webhook-level check)
      3. Load conversation state via conversationStore.getState(from). If null, treat as new conversation.
      4. Add user message to conversation history via conversationStore.addToHistory(from, 'user', text)
      5. Build conversation history array from state for LLM context
      6. Call extractIntent(anthropicClient, text, conversationHistory) to get CalendarIntent
      7. Format response via formatIntentResponse(intent)
      8. Send response via sendWhatsAppMessage(config.WHATSAPP_PHONE_NUMBER_ID, config.WHATSAPP_ACCESS_TOKEN, from, responseText)
      9. Add assistant response to conversation history via conversationStore.addToHistory(from, 'assistant', responseText)
      10. Update conversation state with current intent and pending entities
      11. Mark message as processed in idempotency store
      12. Log the complete processing pipeline (messageId, intent, confidence, response length) at info level
    - Handle errors gracefully:
      - If Claude fails: send a fallback message ("Sorry, I'm having trouble understanding right now. Please try again.")
      - If WhatsApp send fails: log error but don't retry sending (job will retry from scratch)
      - Always mark message as processed even on partial failure to prevent retry loops
    - Set concurrency: MAX_CONCURRENT_JOBS from constants (3)
    - Attach event handlers: completed, failed, error (see research Pattern BullMQ Worker Setup)
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm all types compile.
    Verify the worker processor follows the correct order: idempotency check -> load state -> add to history -> extract intent -> format response -> send message -> save state -> mark processed.
    Verify error handling sends a fallback message on Claude failure.
    Verify concurrency is set from constants.
  </verify>
  <done>
    sendWhatsAppMessage sends text messages via WhatsApp Cloud API.
    formatIntentResponse generates human-friendly responses for each intent type (Phase 1 placeholders).
    BullMQ worker processes messages through the full pipeline: state -> Claude -> format -> send -> update state.
    Error handling sends fallback messages and prevents retry loops.
  </done>
</task>

<task type="auto">
  <name>Task 2: Main entry point wiring all components with graceful shutdown</name>
  <files>
    src/index.ts
  </files>
  <action>
    Create src/index.ts as the application entry point that wires everything together:

    1. Validate environment: `const config = validateEnv()` -- exits on failure
    2. Create logger: configure pino with log level from config
    3. Create PostgreSQL pool: import pool from db/pool.ts
    4. Create Redis connections:
       - queueConnection = createQueueConnection(config.REDIS_URL) -- for producer
       - workerConnection = createWorkerConnection(config.REDIS_URL) -- for worker (maxRetriesPerRequest: null)
    5. Create service instances:
       - anthropicClient = createAnthropicClient(config.ANTHROPIC_API_KEY)
       - conversationStore = new ConversationStore(pool)
       - idempotencyStore = new IdempotencyStore(queueConnection) -- reuse queue connection for idempotency
       - messageQueue = createMessageQueue(queueConnection)
    6. Create Fastify instance:
       - Configure with pino logger
       - Add custom content-type parser for raw body capture (see research Pattern 2):
         `fastify.addContentTypeParser('application/json', { parseAs: 'buffer' }, ...)` that attaches rawBody to request
       - Register @fastify/rate-limit (100 requests per minute per IP as a sensible default)
       - Register webhookRoutes plugin, passing messageQueue, idempotencyStore, and config as options
    7. Create BullMQ worker:
       - worker = createMessageWorker(workerConnection, { anthropicClient, conversationStore, idempotencyStore, config, logger })
    8. Start Fastify:
       - `await fastify.listen({ port: config.PORT, host: '0.0.0.0' })`
       - Log the startup message with port number
    9. Graceful shutdown:
       - Listen for SIGTERM and SIGINT signals
       - On signal: log shutdown, close Fastify, close BullMQ worker (await worker.close()), close Redis connections, close PostgreSQL pool
       - Call process.exit(0) after all cleanup

    IMPORTANT: The raw body content-type parser MUST be registered BEFORE any routes. Fastify processes parsers in registration order.

    IMPORTANT: Use top-level await since the project uses ESM ("type": "module").
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm the entry point compiles with all imports.
    Verify the content-type parser is registered before webhookRoutes.
    Verify graceful shutdown closes all resources (Fastify, worker, Redis, PG pool).
    Verify the server binds to 0.0.0.0 (not localhost -- required for cloud deployment).
  </verify>
  <done>
    src/index.ts wires all components together: config, database, Redis, queue, worker, webhook routes.
    Raw body parser captures body before JSON parsing for signature validation.
    Rate limiting protects the webhook endpoint.
    Graceful shutdown cleans up all resources on SIGTERM/SIGINT.
    Application starts with a single `npm run dev` command.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify application starts and webhook verification works</name>
  <action>
    Human verification of the complete Phase 1 application.
  </action>
  <what-built>
    Complete end-to-end message processing pipeline for Phase 1:
    - Fastify webhook server with WhatsApp signature validation
    - BullMQ async message queue with Redis
    - Claude LLM intent extraction via tool use with prompt caching
    - PostgreSQL conversation state management
    - WhatsApp message sending via Cloud API
    - Full pipeline: receive message -> validate -> queue -> process via Claude -> respond via WhatsApp

    This is the entire Phase 1 application. Before testing end-to-end with WhatsApp (which requires Meta Business account setup), verify the application starts and the code structure looks correct.
  </what-built>
  <how-to-verify>
    1. Ensure PostgreSQL and Redis are running locally (or via Docker):
       - `docker run -d -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres:16`
       - `docker run -d -p 6379:6379 redis:7`
    2. Copy .env.example to .env and fill in values:
       - DATABASE_URL=postgresql://postgres:postgres@localhost:5432/family_coordinator
       - REDIS_URL=redis://localhost:6379
       - ANTHROPIC_API_KEY=sk-ant-... (your key)
       - WHATSAPP_* values can be placeholder strings for now
    3. Create the database: `createdb family_coordinator` (or via psql)
    4. Run migrations: `npm run migrate`
    5. Start the dev server: `npm run dev`
    6. Verify the server starts without errors and logs the port
    7. Test webhook verification: `curl "http://localhost:3000/webhook?hub.mode=subscribe&hub.verify_token=YOUR_VERIFY_TOKEN&hub.challenge=test123"` -- should return `test123`
    8. Review the code structure: does the project layout match the planned architecture?
  </how-to-verify>
  <verify>Human confirms the server starts and webhook verification curl returns challenge string.</verify>
  <done>Server starts without errors, webhook verification endpoint returns challenge, code structure matches architecture.</done>
  <resume-signal>Type "approved" if the server starts and webhook verification works, or describe any issues.</resume-signal>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm run dev` starts the server without crashing
- GET /webhook returns challenge for valid verify token
- POST /webhook with invalid signature returns 401
- BullMQ worker is running and waiting for jobs
- Graceful shutdown closes all connections
</verification>

<success_criteria>
- Application starts with `npm run dev` and binds to configured port
- Webhook verification works (GET /webhook returns challenge)
- Full message pipeline is wired: webhook -> queue -> worker -> Claude -> WhatsApp response
- Conversation state persists across messages from the same phone number
- Duplicate messages are detected and skipped
- Graceful shutdown cleanly closes all resources
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-webhook-infrastructure/01-04-SUMMARY.md`
</output>

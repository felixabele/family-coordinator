---
phase: 05-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/health.ts
  - src/index.ts
  - ecosystem.config.cjs
  - .env.production.example
  - scripts/deploy.sh
  - scripts/backup.sh
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Health check endpoint responds with JSON status on GET /health"
    - "PM2 can start the app using ecosystem.config.cjs"
    - "Deploy script pulls latest code, installs deps, runs migrations, and restarts PM2"
    - "Backup script creates a pg_dump and can be scheduled via cron"
  artifacts:
    - path: "src/health.ts"
      provides: "Lightweight HTTP health check server"
      min_lines: 20
    - path: "ecosystem.config.cjs"
      provides: "PM2 process management config"
      min_lines: 15
    - path: "scripts/deploy.sh"
      provides: "Deployment automation script"
      min_lines: 10
    - path: "scripts/backup.sh"
      provides: "PostgreSQL backup script"
      min_lines: 10
    - path: ".env.production.example"
      provides: "Production environment template"
      min_lines: 8
  key_links:
    - from: "src/index.ts"
      to: "src/health.ts"
      via: "import and start/stop health server in startup/shutdown"
      pattern: "import.*health"
    - from: "ecosystem.config.cjs"
      to: "src/index.ts"
      via: "PM2 script entry point"
      pattern: "src/index.ts"
---

<objective>
Create all production deployment artifacts: health check endpoint integrated into the app, PM2 ecosystem config, production env template, deploy script, and backup script.

Purpose: Prepare the codebase for bare-metal VPS deployment with PM2 process management, automated backups, and health monitoring -- no Docker, no reverse proxy, no complexity.

Output: Health check endpoint in app, PM2 config, deploy script, backup script, production env template.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/index.ts
@src/db/pool.ts
@src/config/env.ts
@src/utils/logger.ts
@package.json
@.env.example
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add lightweight HTTP health check endpoint</name>
  <files>src/health.ts, src/index.ts</files>
  <action>
Create `src/health.ts` with a minimal HTTP health check server using Node.js built-in `http` module (no Express/Fastify -- zero dependencies).

The health server should:

- Listen on port 3000 (or `HEALTH_PORT` env var if set)
- Respond to `GET /health` with JSON: `{ status: "healthy"|"unhealthy", timestamp, uptime, checks: { database: boolean } }`
- Database check: run `SELECT 1` on the pool from `./db/pool.js`
- Return HTTP 200 when healthy, HTTP 503 when unhealthy
- Return 404 for any other path
- Export `startHealthServer()` that returns the server instance and `stopHealthServer(server)` to close it

Integrate into `src/index.ts`:

- Import `startHealthServer` and `stopHealthServer` from `./health.js`
- Call `startHealthServer()` after Signal is connected (after step 6, before shutdown handlers)
- Log the health check port
- In the `shutdown()` function, call `stopHealthServer(server)` before closing Signal client (close health server first so monitoring sees it go down)

IMPORTANT constraints per user decisions:

- NO reverse proxy -- this HTTP server is accessed directly (localhost or VPS IP)
- Keep it minimal -- no middleware, no frameworks
- Do NOT modify env.ts or pool.ts
  </action>
  <verify>
  Run: `npm run format:check` to verify formatting.
  Run: `npx tsc --noEmit` to verify TypeScript compiles.
  Manual: The health endpoint integration can be verified visually by reading src/index.ts and confirming the health server starts after Signal connects and stops during shutdown.
  </verify>
  <done>
- src/health.ts exists with HTTP server responding JSON on /health with database check
- src/index.ts imports and integrates health server in startup and graceful shutdown
- TypeScript compiles without errors
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create PM2 config, deploy script, backup script, and production env template</name>
  <files>ecosystem.config.cjs, .env.production.example, scripts/deploy.sh, scripts/backup.sh, .gitignore</files>
  <action>
Create `ecosystem.config.cjs` (CommonJS for PM2 compatibility):
```javascript
module.exports = {
  apps: [{
    name: "family-coordinator",
    script: "src/index.ts",
    interpreter: "node",
    interpreter_args: "--env-file=.env.production --experimental-strip-types",
    instances: 1,
    exec_mode: "fork",
    autorestart: true,
    watch: false,
    max_memory_restart: "500M",
    min_uptime: "30s",
    max_restarts: 10,
    restart_delay: 5000,
    error_file: "./logs/error.log",
    out_file: "./logs/output.log",
    merge_logs: true,
    log_date_format: "YYYY-MM-DD HH:mm:ss Z",
  }],
};
```

Create `.env.production.example` based on `.env.example` but with production values:

- NODE_ENV=production
- LOG_LEVEL=info
- FAMILY_TIMEZONE=Europe/Berlin
- All secrets as placeholder values with comments explaining where to get them
- DATABASE_URL with localhost PostgreSQL format (user handles pg setup via apt)
- SIGNAL_CLI_PATH=/usr/local/bin/signal-cli (or wherever installed on VPS)

Create `scripts/deploy.sh`:

```bash
#!/bin/bash
set -euo pipefail

cd "$(dirname "$0")/.."

echo "=== Deploying Family Coordinator ==="

echo "1. Pulling latest code..."
git pull --ff-only

echo "2. Installing dependencies..."
npm ci --omit=dev

echo "3. Running database migrations..."
node --env-file=.env.production --experimental-strip-types src/db/migrate.ts

echo "4. Restarting application..."
pm2 restart ecosystem.config.cjs --env production || pm2 start ecosystem.config.cjs

echo "5. Saving PM2 process list..."
pm2 save

echo "=== Deployment complete ==="
pm2 status
```

Create `scripts/backup.sh`:

```bash
#!/bin/bash
set -euo pipefail

# Configuration
DB_NAME="family_coordinator"
DB_USER="family_coordinator"
BACKUP_DIR="$HOME/backups/family-coordinator"
RETENTION_DAYS=7

# Create backup directory if needed
mkdir -p "$BACKUP_DIR"

# Create timestamped backup
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/${DB_NAME}_${TIMESTAMP}.sql.gz"

pg_dump -U "$DB_USER" "$DB_NAME" | gzip > "$BACKUP_FILE"

echo "Backup created: $BACKUP_FILE"

# Remove backups older than retention period
find "$BACKUP_DIR" -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete

echo "Old backups cleaned (retention: $RETENTION_DAYS days)"
```

Add a comment at the top of backup.sh:

```
# To schedule daily backups at 2 AM, add to crontab (crontab -e):
# 0 2 * * * /opt/family-coordinator/scripts/backup.sh >> /opt/family-coordinator/logs/backup.log 2>&1
```

Update `.gitignore` to add:

- `logs/` directory (PM2 log output)
- `.env.production` (the actual production env file, not the .example)

Make both scripts executable: `chmod +x scripts/deploy.sh scripts/backup.sh`

Create `logs/` directory with a `.gitkeep` file so git tracks the directory.
</action>
<verify>
Run: `npm run format:check` to verify formatting on ecosystem.config.cjs.
Verify: `bash -n scripts/deploy.sh` and `bash -n scripts/backup.sh` to check shell syntax.
Verify: `.gitignore` contains `logs/` and `.env.production`.
Verify: `ls -la scripts/` shows execute permissions on both scripts.
</verify>
<done>

- ecosystem.config.cjs exists with PM2 config for single-instance fork mode
- .env.production.example exists with all required vars documented
- scripts/deploy.sh exists and is executable, performs git pull + npm ci + migrate + pm2 restart
- scripts/backup.sh exists and is executable, runs pg_dump with gzip and retention cleanup
- .gitignore updated with logs/ and .env.production
- logs/.gitkeep exists
  </done>
  </task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- TypeScript compiles without errors
2. `npm run format:check` -- all files pass Prettier
3. `bash -n scripts/deploy.sh && bash -n scripts/backup.sh` -- shell scripts have valid syntax
4. Health check module exports startHealthServer and stopHealthServer
5. src/index.ts integrates health server in startup and shutdown
6. ecosystem.config.cjs runs app with --env-file=.env.production and --experimental-strip-types
</verification>

<success_criteria>
All production deployment artifacts exist and are syntactically valid. Health check endpoint is integrated into the application lifecycle. PM2 can manage the app. Deploy and backup scripts are ready for use on VPS.
</success_criteria>

<output>
After completion, create `.planning/phases/05-deployment/05-01-SUMMARY.md`
</output>

---
phase: 02-calendar-crud
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/llm/prompts.ts
  - src/llm/types.ts
  - src/llm/intent.ts
  - src/signal/listener.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Bot responds in German with casual du-form tone"
    - "Bot shows events in compact one-line-per-event format"
    - "Bot confirms every calendar mutation with a summary of what changed"
    - "Bot asks for clarification when multiple events match"
    - "Bot asks for time when user provides date but no time for event creation"
    - "Calendar operations are wired end-to-end: Signal message -> Claude -> Google Calendar -> Signal response"
    - "Empty calendar state shows simple German message"
  artifacts:
    - path: "src/llm/prompts.ts"
      provides: "German system prompt for calendar intent extraction with Phase 2 behavior"
      contains: "German"
    - path: "src/signal/listener.ts"
      provides: "Message handler with real calendar operations replacing Phase 1 stubs"
      contains: "listEvents|createEvent|updateEvent|deleteEvent"
    - path: "src/index.ts"
      provides: "Entry point wiring CalendarClient into message listener dependencies"
      contains: "createCalendarClient"
  key_links:
    - from: "src/signal/listener.ts"
      to: "src/calendar/operations.ts"
      via: "import and function calls"
      pattern: "import.*calendar/operations"
    - from: "src/index.ts"
      to: "src/calendar/client.ts"
      via: "createCalendarClient in startup sequence"
      pattern: "createCalendarClient"
    - from: "src/signal/listener.ts"
      to: "src/llm/intent.ts"
      via: "extractIntent for intent parsing"
      pattern: "extractIntent"
---

<objective>
Wire Google Calendar operations into the Signal message pipeline: update Claude prompts for German responses, replace Phase 1 stub responses with real calendar CRUD operations, and connect the CalendarClient in the application entry point.

Purpose: This plan transforms the bot from a stub-response demo into a working calendar assistant. After this plan, a family member can send a Signal message like "Was steht morgen an?" and receive real events from Google Calendar.

Output: Fully integrated Signal-to-Calendar pipeline responding in casual German.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-calendar-crud/02-RESEARCH.md
@.planning/phases/02-calendar-crud/02-CONTEXT.md
@.planning/phases/02-calendar-crud/02-01-SUMMARY.md

@src/llm/prompts.ts
@src/llm/types.ts
@src/llm/intent.ts
@src/signal/listener.ts
@src/index.ts
@src/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update LLM prompts and types for German calendar operations</name>
  <files>
    src/llm/prompts.ts
    src/llm/types.ts
    src/llm/intent.ts
  </files>
  <action>
1. Rewrite `src/llm/prompts.ts` — replace the English system prompt with a German-aware calendar assistant prompt:

Key changes to CALENDAR_SYSTEM_PROMPT:

- Instruct Claude to respond in German, using casual du-form ("Klar, hab ich eingetragen!")
- Instruct Claude to ALWAYS use the parse_calendar_intent tool — never free-text responses
- Keep intent types the same: create_event, query_events, update_event, delete_event, greeting, help, unclear
- Update entity extraction: Claude should extract title, date (YYYY-MM-DD), time (HH:mm), duration_minutes
- Add new entity: `end_time` (HH:mm) — for when user specifies explicit end time ("3pm bis 5pm")
- Add new entity: `event_search_query` — for update/delete intents, the search text to find the target event
- Date/time resolution rules remain the same (relative dates -> YYYY-MM-DD, time -> HH:mm 24h)
- Add rule: When no time is given for create_event, set confidence < 0.7 and ask for time in clarification_needed (per user decision: "bot asks for a time before creating")
- Add rule: clarification_needed messages MUST be in German, casual du-form
- Keep prompt >500 tokens for prompt caching benefit
- Update examples to German:
  - "Trag Fußball am Dienstag um 16 Uhr ein" -> create_event
  - "Was steht heute an?" -> query_events
  - "Verschieb den Zahnarzt auf Donnerstag" -> update_event
  - "Streich das Fußball diese Woche" -> delete_event
  - "Hallo!" -> greeting

2. Update `src/llm/types.ts` — extend CalendarEntities:
   - Add `end_time?: string` field (HH:mm format) for explicit end times
   - Add `event_search_query?: string` field for update/delete target identification
   - Update CalendarEntitiesSchema to include new optional fields
   - Keep all existing fields (title, date, time, duration_minutes)

3. Update `src/llm/intent.ts` — update the tool definition:
   - Add `end_time` property to the entities object in calendarIntentTool input_schema:
     `end_time: { type: "string", description: "Event end time in HH:MM 24-hour format (when user specifies explicit end time)" }`
   - Add `event_search_query` property:
     `event_search_query: { type: "string", description: "Search text to find the target event for update/delete operations" }`
   - Keep everything else in intent.ts the same (extractIntent function, message building, cache metrics)
     </action>
     <verify>
     Run `npx tsc --noEmit` — no type errors.
     Verify German prompt: `grep -c 'deutsch\|German\|du-form\|Klar' src/llm/prompts.ts` shows matches.
     Verify new entities: `grep 'end_time\|event_search_query' src/llm/types.ts` shows both fields.
     Verify tool schema updated: `grep 'end_time\|event_search_query' src/llm/intent.ts` shows both in tool definition.
     </verify>
     <done>
     System prompt instructs Claude to respond in casual German du-form. Entity extraction includes end_time and event_search_query for Phase 2 operations. Tool definition matches updated type schema. Prompt >500 tokens for caching.
     </done>
     </task>

<task type="auto">
  <name>Task 2: Wire calendar operations into Signal listener and application entry point</name>
  <files>
    src/signal/listener.ts
    src/index.ts
  </files>
  <action>
1. Update `src/signal/listener.ts`:

**Add CalendarClient to MessageListenerDeps:**

- Import CalendarClient from `../calendar/client.js`
- Add `calendarClient: CalendarClient` to MessageListenerDeps interface

**Import calendar operations:**

- Import `listEvents`, `findEvents`, `createEvent`, `updateEvent`, `deleteEvent` from `../calendar/operations.js`
- Import `inferEventDate`, `formatEventTime`, `formatDayName` from `../calendar/timezone.js`
- Import `CalendarEvent`, `CalendarError` from `../calendar/types.js`

**Rewrite `generateResponse` to an async function `handleIntent`:**

- Change signature: `async function handleIntent(intent: CalendarIntent, deps: MessageListenerDeps): Promise<string>`
- This function now performs actual calendar operations, not stub responses

**Intent handlers (all responses in German, casual du-form):**

**greeting:**

- Return: "Hey! Ich bin dein Familienkalender-Bot. Schreib mir einfach, was du wissen oder eintragen willst!"

**help:**

- Return German help text:
  ```
  Das kann ich für dich tun:
  - Termine anzeigen: "Was steht heute an?"
  - Termin eintragen: "Trag Fußball Dienstag um 16 Uhr ein"
  - Termin verschieben: "Verschieb den Zahnarzt auf Donnerstag"
  - Termin löschen: "Streich das Fußball diese Woche"
  ```

**query_events:**

- If no date in entities: use today's date (from timezone utility, in family timezone)
- Call `listEvents(deps.calendarClient, date)`
- If no events: return `"${formatDayName(date, tz)} ist frei!"` (per user decision: empty state is simple message)
- If events exist: format as compact one-line-per-event (per user decision):
  Format: `"HH:mm - Summary"` for each event, joined by `" | "` for same-day
  Example: `"15:00 - Zahnarzt | 17:00 - Fußball"`
- For all-day events, show just the summary without time

**create_event:**

- If confidence < 0.7 or clarification_needed: return the clarification message (already in German from Claude)
- If no time in entities: return clarification asking for time (per user decision: "bot asks for a time before creating")
- If no date in entities: use `inferEventDate(time, tz)` to determine today/tomorrow
- Calculate duration: use `end_time` if provided (compute difference), else `duration_minutes` if provided, else default 60
- Call `createEvent(deps.calendarClient, { summary: title, date, time, durationMinutes })`
- Return confirmation: `"Klar, hab ich eingetragen! ${title}, ${formattedDay} ${formattedTime}-${formattedEndTime}"` (per user decision: mutations show summary of what changed)

**update_event:**

- If confidence < 0.7 or clarification_needed: return the clarification message
- Determine search date: use entities.date or today
- Call `findEvents(deps.calendarClient, searchDate, entities.event_search_query || entities.title)`
- If `notFound`: return `"Ich finde keinen passenden Termin."` (German)
- If `candidates` (multiple matches): format numbered list and ask which one:
  ```
  "Welchen meinst du?
  1) Zahnarzt 15:00
  2) Fußball 17:00"
  ```
  (per user decision: "bot lists matching events with numbers and asks which one")
- If single `event`: apply the update using `updateEvent()`
- Return confirmation showing the result: `"Geändert: ${title} jetzt ${newDay} ${newTime}"` (per user decision: mutations show summary)

**delete_event:**

- If confidence < 0.7 or clarification_needed: return the clarification message
- Determine search date and find events (same pattern as update)
- If `notFound`: return `"Ich finde keinen passenden Termin."`
- If `candidates`: return numbered disambiguation list (same pattern as update)
- If single `event`: call `deleteEvent(deps.calendarClient, event.id)`
- Return confirmation: `"Erledigt! ${title} am ${formattedDay} wurde gelöscht."` (per user decision: "Deletes execute immediately — bot confirms what was deleted after the fact")

**unclear:**

- Return `intent.clarification_needed` or `"Das hab ich nicht ganz verstanden. Schreib mir einfach, was du mit dem Kalender machen möchtest!"`

**Error handling in handleIntent:**

- Wrap calendar operations in try/catch
- Catch CalendarError and return appropriate German error messages:
  - PERMISSION_DENIED: `"Zugriff auf den Kalender verweigert. Bitte prüf die Freigabe-Einstellungen."`
  - RATE_LIMITED: `"Zu viele Anfragen, probier's gleich nochmal."`
  - NOT_FOUND: `"Den Termin gibt's nicht mehr."`
  - API_ERROR: `"Fehler beim Kalender-Zugriff. Probier's nochmal."`

**Update the message event handler:**

- Replace `const response = generateResponse(intent)` with `const response = await handleIntent(intent, deps)`
- Update error response message to German: `"Entschuldigung, da ist was schiefgelaufen. Probier's nochmal."`

2. Update `src/index.ts`:

   **Import CalendarClient:**
   - Import `createCalendarClient` from `./calendar/client.js`

   **Create CalendarClient in startup sequence:**
   - After creating anthropicClient (step 2), add:
     ```typescript
     const calendarClient = createCalendarClient(
       config.GOOGLE_SERVICE_ACCOUNT_KEY_FILE,
       config.GOOGLE_CALENDAR_ID,
       config.FAMILY_TIMEZONE,
     );
     ```
   - Log calendar client creation (mask calendar ID in log)

   **Pass CalendarClient to setupMessageListener:**
   - Add `calendarClient` to the deps object passed to `setupMessageListener()`

   **Update startup log message:**
   - Change the rocket emoji log to German or neutral: log that both Signal and Calendar are connected
     </action>
     <verify>
     Run `npx tsc --noEmit` — no type errors.
     Verify calendar wired into listener: `grep 'calendarClient' src/signal/listener.ts` shows calendarClient in deps and usage.
     Verify calendar wired into index: `grep 'createCalendarClient' src/index.ts` shows import and usage.
     Verify German responses: `grep -c 'Klar\|Erledigt\|Welchen meinst\|ist frei' src/signal/listener.ts` shows German text.
     Verify no Phase 1 stubs remain: `grep -c 'Phase 2' src/signal/listener.ts` returns 0 (no more "coming in Phase 2" messages).
     Verify imports: `grep 'calendar/operations\|calendar/client\|calendar/timezone\|calendar/types' src/signal/listener.ts` shows all calendar imports.
     </verify>
     <done>
     Signal listener handles all calendar intents with real Google Calendar operations. All responses are in German with casual du-form. Phase 1 stub messages completely replaced. Disambiguation shows numbered list for multiple matches. Empty state shows simple German message. CalendarClient created in entry point and passed through to listener. Error handling returns German error messages classified by type.
     </done>
     </task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. No "Phase 2" or "coming in Phase 2" stub messages remain in listener.ts
3. All calendar operations imported and called in listener.ts
4. CalendarClient created in index.ts and passed to setupMessageListener
5. System prompt instructs German responses with du-form
6. Compact event format used: "HH:mm - Title | HH:mm - Title"
7. Disambiguation returns numbered list for multiple matches
8. Empty state returns simple German message (e.g., "Samstag ist frei!")
9. Mutation confirmations show what changed
</verification>

<success_criteria>

- End-to-end pipeline works: Signal message -> Claude intent extraction -> Google Calendar API -> German response via Signal
- Bot responds exclusively in German with casual du-form tone
- Events displayed in compact one-line-per-event format
- Every calendar mutation confirmed with summary of what changed
- Disambiguation asks user to choose when multiple events match
- Bot asks for time when creating events without time specified
- Error messages are user-friendly German text
- No Phase 1 stub responses remain
  </success_criteria>

<output>
After completion, create `.planning/phases/02-calendar-crud/02-02-SUMMARY.md`
</output>

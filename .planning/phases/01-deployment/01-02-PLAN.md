---
phase: 01-deployment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ecosystem.config.cjs
  - .env.production.example
  - scripts/deploy.sh
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "PM2 ecosystem config runs the app as a single-instance fork-mode process with auto-restart"
    - "Production environment template documents all required secrets and configuration"
    - "Deploy script automates the full deployment workflow (pull, build, migrate, restart)"
    - ".gitignore protects secrets directory and production data from accidental commits"
  artifacts:
    - path: "ecosystem.config.cjs"
      provides: "PM2 process management configuration"
      contains: "family-coordinator"
    - path: ".env.production.example"
      provides: "Production environment variable template"
      contains: "_FILE"
    - path: "scripts/deploy.sh"
      provides: "Automated deployment script"
      contains: "docker compose"
    - path: ".gitignore"
      provides: "Updated git exclusions for production artifacts"
      contains: "secrets/"
  key_links:
    - from: "scripts/deploy.sh"
      to: "docker-compose.production.yml"
      via: "compose file reference in deploy commands"
      pattern: "docker compose -f docker-compose.production.yml"
    - from: "ecosystem.config.cjs"
      to: "src/index.ts"
      via: "PM2 script entry point"
      pattern: "src/index.ts"
---

<objective>
Create production operations tooling: PM2 ecosystem configuration for optional bare-metal deployment, production environment template, automated deployment script, and updated .gitignore for production security.

Purpose: Give the user a complete, documented deployment workflow whether using Docker Compose (primary) or PM2 on bare metal (alternative).
Output: PM2 config, production env template, deploy script, updated .gitignore.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-deployment/01-RESEARCH.md

@package.json
@.env.example
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PM2 ecosystem config and production env template</name>
  <files>ecosystem.config.cjs, .env.production.example</files>
  <action>
  1. Create `ecosystem.config.cjs` (CommonJS — PM2 doesn't support ESM config):
     ```javascript
     module.exports = {
       apps: [{
         name: 'family-coordinator',
         script: 'src/index.ts',
         interpreter: 'node',
         interpreter_args: '--experimental-strip-types',
         instances: 1,           // Signal bot MUST be single instance (stateful)
         exec_mode: 'fork',      // Not cluster — single persistent Signal connection
         autorestart: true,
         watch: false,            // Never in production
         max_memory_restart: '500M',
         env_production: {
           NODE_ENV: 'production',
         },
         error_file: './logs/error.log',
         out_file: './logs/output.log',
         log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
         merge_logs: true,
         min_uptime: '30s',       // Must stay up 30s to count as successful start
         max_restarts: 10,        // Max restart attempts before stopping
         restart_delay: 5000,     // Wait 5s between restarts
       }],
     };
     ```
     - Use .cjs extension because the project is ESM (`"type": "module"` in package.json) and PM2 requires CommonJS for config files
     - Single instance + fork mode because Signal bot maintains a stateful daemon connection
     - No --env-file flag — PM2 bare-metal deployment uses system env vars or dotenv

2. Create `.env.production.example`:

   ```bash
   # ========================================
   # Family Coordinator — Production Config
   # ========================================
   # Copy to .env.production and fill in actual values.
   # For Docker Compose deployment, use secrets/ directory instead.
   # For PM2 bare-metal deployment, use this file with --env-file flag.

   # Application
   NODE_ENV=production
   LOG_LEVEL=info

   # Signal Configuration
   # Phone number in E.164 format — must be registered with signal-cli
   SIGNAL_PHONE_NUMBER=+491234567890
   # Path to signal-cli binary (default: signal-cli in PATH)
   # SIGNAL_CLI_PATH=/usr/local/bin/signal-cli

   # Anthropic API
   ANTHROPIC_API_KEY=sk-ant-your-production-key

   # Google Calendar
   # Path to service account JSON key file
   GOOGLE_SERVICE_ACCOUNT_KEY_FILE=./keys/service-account.json
   # Calendar ID (from Google Calendar Settings)
   GOOGLE_CALENDAR_ID=your-calendar-id@group.calendar.google.com
   # Family timezone (IANA format)
   FAMILY_TIMEZONE=Europe/Berlin

   # Database
   # For Docker Compose: postgresql://postgres:PASSWORD@postgres:5432/family_coordinator
   # For bare metal: postgresql://postgres:PASSWORD@localhost:5432/family_coordinator
   DATABASE_URL=postgresql://postgres:CHANGE_ME@localhost:5432/family_coordinator

   # ========================================
   # Docker Secrets (Docker Compose only)
   # ========================================
   # When using Docker Compose, secrets are read from files.
   # Create these files in the secrets/ directory:
   #   secrets/signal-phone.txt
   #   secrets/anthropic-api-key.txt
   #   secrets/google-service-account.json
   #   secrets/google-calendar-id.txt
   #   secrets/database-url.txt
   #   secrets/db-password.txt
   ```

   </action>
   <verify>

- `node -e "require('./ecosystem.config.cjs')"` parses without error
- `.env.production.example` file exists and contains all required env vars from .env.example
- PM2 config specifies `instances: 1` and `exec_mode: 'fork'`
  </verify>
  <done>
- PM2 ecosystem config defines single-instance fork-mode process with auto-restart and log management
- Production environment template documents all required configuration for both Docker and bare-metal deployments
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create deployment script and update .gitignore</name>
  <files>scripts/deploy.sh, .gitignore</files>
  <action>
  1. Create `scripts/deploy.sh` (executable deployment automation):
     ```bash
     #!/usr/bin/env bash
     set -euo pipefail

     # Family Coordinator — Production Deployment Script
     # Usage: ./scripts/deploy.sh [command]
     # Commands: deploy, stop, logs, status, backup, migrate

     COMPOSE_FILE="docker-compose.production.yml"
     APP_NAME="family-coordinator"

     # Colors for output
     RED='\033[0;31m'
     GREEN='\033[0;32m'
     YELLOW='\033[1;33m'
     NC='\033[0m'

     log() { echo -e "${GREEN}[deploy]${NC} $1"; }
     warn() { echo -e "${YELLOW}[warn]${NC} $1"; }
     error() { echo -e "${RED}[error]${NC} $1"; exit 1; }

     # Verify prerequisites
     check_prerequisites() {
       command -v docker >/dev/null 2>&1 || error "Docker is not installed"
       command -v docker compose >/dev/null 2>&1 || error "Docker Compose is not installed"
       [ -f "$COMPOSE_FILE" ] || error "$COMPOSE_FILE not found. Run from project root."
       [ -d "secrets" ] || error "secrets/ directory not found. Create it with required secret files."
       [ -f "family-members.json" ] || error "family-members.json not found."
     }

     # Deploy or update the application
     cmd_deploy() {
       check_prerequisites
       log "Pulling latest changes..."
       git pull --ff-only 2>/dev/null || warn "Not a git repo or no remote — skipping pull"

       log "Building Docker image..."
       docker compose -f "$COMPOSE_FILE" build

       log "Running database migrations..."
       docker compose -f "$COMPOSE_FILE" run --rm app node --experimental-strip-types src/db/migrate.ts

       log "Starting services..."
       docker compose -f "$COMPOSE_FILE" up -d

       log "Waiting for health check..."
       sleep 10
       if docker compose -f "$COMPOSE_FILE" ps | grep -q "healthy"; then
         log "Deployment successful! All services healthy."
       else
         warn "Services starting — check status with: ./scripts/deploy.sh status"
       fi
     }

     # Stop all services
     cmd_stop() {
       log "Stopping services..."
       docker compose -f "$COMPOSE_FILE" down
       log "Services stopped."
     }

     # View application logs
     cmd_logs() {
       docker compose -f "$COMPOSE_FILE" logs -f --tail=100 app
     }

     # Show service status
     cmd_status() {
       docker compose -f "$COMPOSE_FILE" ps
       echo ""
       log "Health check:"
       curl -s http://localhost:3000/health 2>/dev/null | python3 -m json.tool 2>/dev/null || warn "Health endpoint not reachable"
     }

     # Trigger manual backup
     cmd_backup() {
       log "Triggering database backup..."
       docker compose -f "$COMPOSE_FILE" exec postgres pg_dump -U postgres family_coordinator | gzip > "data/backups/manual-$(date +%Y%m%d-%H%M%S).sql.gz"
       log "Backup saved to data/backups/"
     }

     # Run database migrations
     cmd_migrate() {
       log "Running database migrations..."
       docker compose -f "$COMPOSE_FILE" run --rm app node --experimental-strip-types src/db/migrate.ts
       log "Migrations complete."
     }

     # Main
     case "${1:-deploy}" in
       deploy)  cmd_deploy ;;
       stop)    cmd_stop ;;
       logs)    cmd_logs ;;
       status)  cmd_status ;;
       backup)  cmd_backup ;;
       migrate) cmd_migrate ;;
       *)       echo "Usage: $0 {deploy|stop|logs|status|backup|migrate}"; exit 1 ;;
     esac
     ```
     - Make executable: `chmod +x scripts/deploy.sh`
     - Uses `docker compose -f` (v2 syntax, not `docker-compose`)
     - Migration runs via `docker compose run --rm` to execute in a temporary container connected to the same network

2. Update `.gitignore` — append production-specific exclusions:

   ```
   # Production secrets and data
   secrets/
   data/
   .env.production
   logs/
   ecosystem.config.cjs

   # Signal CLI data
   .local/
   ```

   - Keep existing entries (node_modules, dist, .env, \*.log, .DS_Store, keys)
   - Add secrets/, data/, .env.production, logs/, ecosystem.config.cjs, .local/
   - ecosystem.config.cjs excluded because it may contain env-specific values
     </action>
     <verify>

- `bash -n scripts/deploy.sh` passes (no syntax errors)
- `scripts/deploy.sh` is executable (`ls -la scripts/deploy.sh` shows +x)
- `.gitignore` contains entries for `secrets/`, `data/`, `.env.production`
- `git status` does not show secrets/ or data/ as untracked
  </verify>
  <done>
- Deploy script automates full lifecycle: deploy, stop, logs, status, backup, migrate
- .gitignore protects production secrets, data volumes, and logs from accidental commits
- Both Docker Compose and PM2 deployment paths are documented and supported
  </done>
  </task>

</tasks>

<verification>
- PM2 config parseable: `node -e "require('./ecosystem.config.cjs')"`
- Deploy script valid: `bash -n scripts/deploy.sh`
- .gitignore includes production exclusions
- .env.production.example documents all required secrets
- No hardcoded secrets in any committed file
</verification>

<success_criteria>
Complete deployment operations toolkit: PM2 config for bare-metal option, production env template with clear documentation, automated deploy script for Docker Compose workflow, and comprehensive .gitignore for production security. A user can deploy by following the documented steps without guessing configuration.
</success_criteria>

<output>
After completion, create `.planning/phases/01-deployment/01-02-SUMMARY.md`
</output>

---
phase: 04-advanced-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/llm/types.ts
  - src/llm/prompts.ts
  - src/llm/intent.ts
  - src/calendar/types.ts
  - src/calendar/recurring.ts
  - src/calendar/operations.ts
autonomous: true

must_haves:
  truths:
    - "LLM extracts recurrence entities (frequency, day_of_week, end_date) from German natural language"
    - "RRULE strings are correctly formatted for daily, weekly, and monthly patterns"
    - "Recurring events are created in Google Calendar with valid RRULE recurrence field"
    - "Confirmation message shows next 3 occurrences after creating a recurring event"
    - "LLM parses German relative dates (nächsten Dienstag, übermorgen, in 2 Wochen) accurately"
    - "Vague time expressions resolve to sensible defaults (morgens=09:00, abends=19:00)"
  artifacts:
    - path: "src/calendar/recurring.ts"
      provides: "RRULE formatting, next occurrence calculation, and recurring event trimming"
      exports: ["formatRRule", "calculateNextOccurrences", "trimRecurringEvent"]
    - path: "src/llm/types.ts"
      provides: "RecurrenceEntities interface and Zod schema extension"
      contains: "RecurrenceEntities"
    - path: "src/llm/prompts.ts"
      provides: "Enhanced German date parsing and recurring event detection rules"
      contains: "RRULE"
    - path: "src/calendar/operations.ts"
      provides: "createRecurringEvent function"
      exports: ["createRecurringEvent"]
  key_links:
    - from: "src/llm/intent.ts"
      to: "src/llm/types.ts"
      via: "tool schema includes recurrence object"
      pattern: "recurrence"
    - from: "src/calendar/operations.ts"
      to: "src/calendar/recurring.ts"
      via: "createRecurringEvent calls formatRRule"
      pattern: "formatRRule"
    - from: "src/calendar/recurring.ts"
      to: "luxon"
      via: "DateTime for occurrence calculation and UNTIL formatting"
      pattern: "DateTime"
---

<objective>
Add recurring event support (daily/weekly/monthly) with RRULE formatting and enhance the LLM prompt for intelligent German date parsing and recurrence pattern detection.

Purpose: Enables users to create recurring events via natural language ("jeden Dienstag um 16 Uhr") and ensures the LLM accurately resolves German relative dates and vague time expressions.

Output: Recurring event creation with RRULE in Google Calendar, enhanced LLM prompt with German date parsing rules, confirmation messages showing next 3 occurrences.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-features/04-RESEARCH.md

@src/llm/types.ts
@src/llm/prompts.ts
@src/llm/intent.ts
@src/calendar/types.ts
@src/calendar/operations.ts
@src/calendar/timezone.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add recurrence types, RRULE utility, and extend LLM schema</name>
  <files>
    src/llm/types.ts
    src/llm/intent.ts
    src/calendar/recurring.ts
    src/calendar/types.ts
  </files>
  <action>
**1. Extend LLM types (src/llm/types.ts):**

Add `RecurrenceEntities` interface:

```typescript
export interface RecurrenceEntities {
  frequency: "DAILY" | "WEEKLY" | "MONTHLY";
  day_of_week?: "MO" | "TU" | "WE" | "TH" | "FR" | "SA" | "SU";
  end_date?: string; // YYYY-MM-DD format, null = forever
}
```

Add `recurrence` optional field to `CalendarEntities` interface:

```typescript
recurrence?: RecurrenceEntities;
```

Add Zod schema for RecurrenceEntities:

```typescript
export const RecurrenceEntitiesSchema = z.object({
  frequency: z.enum(["DAILY", "WEEKLY", "MONTHLY"]),
  day_of_week: z.enum(["MO", "TU", "WE", "TH", "FR", "SA", "SU"]).optional(),
  end_date: z.string().optional(),
});
```

Add `recurrence` to `CalendarEntitiesSchema`:

```typescript
recurrence: RecurrenceEntitiesSchema.optional(),
```

**2. Extend LLM tool schema (src/llm/intent.ts):**

Add `recurrence` property inside the `entities` object of `calendarIntentTool`:

```typescript
recurrence: {
  type: 'object',
  properties: {
    frequency: {
      type: 'string',
      enum: ['DAILY', 'WEEKLY', 'MONTHLY'],
      description: 'How often the event repeats',
    },
    day_of_week: {
      type: 'string',
      enum: ['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU'],
      description: 'Day of week for weekly recurrence (e.g., TU for Tuesday)',
    },
    end_date: {
      type: 'string',
      description: 'End date in YYYY-MM-DD format. Omit for repeat forever.',
    },
  },
  description: 'Recurring event pattern. Only set when user explicitly requests repetition (jeden, täglich, wöchentlich, monatlich).',
},
```

**3. Create RRULE utility (src/calendar/recurring.ts):**

Create new file with two exported functions:

`formatRRule(input: RRuleInput): string` — Formats RRULE string for Google Calendar API.

- Input: `{ frequency: 'DAILY' | 'WEEKLY' | 'MONTHLY', dayOfWeek?: string, endDate?: string, timezone: string }`
- Build parts array starting with `FREQ=${frequency}`
- If frequency is WEEKLY and dayOfWeek provided, add `BYDAY=${dayOfWeek}`
- If endDate provided, convert to UTC using Luxon: parse endDate in timezone, get endOf('day'), convert toUTC(), format as `yyyyMMdd'T'HHmmss'Z'`, add `UNTIL=${utcString}`
- Return `RRULE:${parts.join(';')}`
- CRITICAL: UNTIL must be in UTC with 'Z' suffix per RFC 5545 (see research pitfall 1)

`calculateNextOccurrences(startDate, startTime, frequency, count, timezone): DateTime[]` — Calculates next N occurrences.

- Parse startDate + startTime in timezone
- Loop `count` times, pushing current datetime, then advancing by 1 day (DAILY), 1 week (WEEKLY), or 1 month (MONTHLY)
- Return array of DateTime objects

Export `RRuleInput` interface.

`trimRecurringEvent(client: CalendarClient, recurringEventId: string, beforeDate: string, timezone: string): Promise<void>` — Trims a recurring event to end before a given date (used for "alle zukünftigen löschen").

- Import CalendarClient from `./client.js`
- Fetch the existing recurring event: `client.calendar.events.get({ calendarId: client.calendarId, eventId: recurringEventId })`
- Parse the existing RRULE from `event.recurrence[0]`
- Calculate UNTIL date: parse `beforeDate` (YYYY-MM-DD) in timezone, subtract 1 day, get endOf('day'), convert to UTC, format as `yyyyMMdd'T'HHmmss'Z'`
- Replace/add UNTIL in the existing RRULE string (if UNTIL already exists, replace it; if not, append it)
- Update the event: `client.calendar.events.patch({ calendarId: client.calendarId, eventId: recurringEventId, requestBody: { recurrence: [updatedRrule] } })`
- This preserves all past instances while removing future ones starting from the given date

**4. Extend calendar types (src/calendar/types.ts):**

Add `CreateRecurringEventInput` interface that extends `CreateEventInput` with recurrence:

```typescript
export interface CreateRecurringEventInput extends CreateEventInput {
  recurrence: {
    frequency: "DAILY" | "WEEKLY" | "MONTHLY";
    dayOfWeek?: string;
    endDate?: string;
  };
}
```

Also add `recurringEventId?: string` to the existing `CalendarEvent` interface. This field is set by Google Calendar API on instances of recurring events and is needed by Plan 04-03 for recurring event deletion scope detection.

  </action>
  <verify>
Run `npx tsc --noEmit` — zero errors. Verify src/calendar/recurring.ts exists with formatRRule, calculateNextOccurrences, and trimRecurringEvent exports. Verify src/llm/types.ts contains RecurrenceEntities. Verify src/llm/intent.ts tool schema includes recurrence property.
  </verify>
  <done>
RecurrenceEntities type and Zod schema added to LLM types. Tool schema extended with recurrence object. RRULE utility created with formatRRule (UTC UNTIL handling), calculateNextOccurrences, and trimRecurringEvent (for "alle zukünftigen löschen" — trims RRULE UNTIL to preserve past instances). CalendarEvent extended with recurringEventId. CreateRecurringEventInput type defined. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance LLM prompt and add createRecurringEvent operation</name>
  <files>
    src/llm/prompts.ts
    src/calendar/operations.ts
  </files>
  <action>
**1. Enhance system prompt (src/llm/prompts.ts):**

Add two new sections to `CALENDAR_SYSTEM_PROMPT` before the `## Wichtige Hinweise` section:

**Section A: German Date Parsing Rules** — Add these rules (per user decision: Claude handles all date parsing, no library):

```

## Erweiterte Datumsauflösung

### Relative Tage

- "heute" → aktuelles Datum
- "morgen" → aktuelles Datum + 1 Tag
- "übermorgen" → aktuelles Datum + 2 Tage
- "gestern" → aktuelles Datum - 1 Tag (für Abfragen)

### Relative Wochen

- "nächste Woche" → 7 Tage ab heute
- "in 2 Wochen" → aktuelles Datum + 14 Tage
- "in einer Woche" → aktuelles Datum + 7 Tage

### Wochentag-Auflösung (KRITISCH)

Wenn heute der gleiche Wochentag ist wie angefragt:

- "nächsten Freitag" an einem Freitag → 7 Tage ab jetzt (der KOMMENDE Freitag, NICHT heute)
- NIEMALS den gleichen Tag für "nächsten [Wochentag]" zurückgeben

Beispiele mit aktuellem Datum 2026-02-16 (Montag):

- "nächsten Dienstag" → 2026-02-17 (morgen, erster Dienstag nach heute)
- "nächsten Montag" → 2026-02-23 (7 Tage ab jetzt, NICHT heute)
- "Dienstag" → 2026-02-17 (Standard: nächstes Vorkommen)

### Monate

- "15. März" → 2026-03-15 (aktuelles Jahr)
- "nächsten Monat" → erster Tag des nächsten Monats
- "in 2 Monaten" → aktuelles Datum + 2 Monate

### Tageszeit-Ausdrücke

- "morgens" → 09:00
- "vormittags" → 10:00
- "mittags" → 12:00
- "nachmittags" → 15:00
- "abends" → 19:00
- "Mittwochabend" → nächster Mittwoch um 19:00

### Datumsformate

- "15.03.2026" → 2026-03-15
- "15.3." → 2026-03-15 (aktuelles Jahr)
- "15. März" → 2026-03-15

### Enddaten (für wiederkehrende Termine)

- "bis Ende März" → 2026-03-31
- "bis Juni" → 2026-06-30 (letzter Tag des Monats)
- "bis 15. März" → 2026-03-15

```

**Section B: Recurring Event Rules** — Per user locked decisions (simple patterns only: daily, weekly, monthly):

```

## Wiederkehrende Termine

Wenn der Benutzer einen wiederkehrenden Termin erstellt, setze das recurrence-Objekt:

- "jeden Tag", "täglich" → recurrence: {frequency: "DAILY"}
- "jede Woche", "wöchentlich" → recurrence: {frequency: "WEEKLY"}
- "jeden Monat", "monatlich" → recurrence: {frequency: "MONTHLY"}

Für wöchentliche Termine den Wochentag extrahieren:

- "jeden Dienstag" → frequency: "WEEKLY", day_of_week: "TU"
- "jeden Montag" → frequency: "WEEKLY", day_of_week: "MO"
- "jeden Mittwoch" → frequency: "WEEKLY", day_of_week: "WE"
- "jeden Donnerstag" → frequency: "WEEKLY", day_of_week: "TH"
- "jeden Freitag" → frequency: "WEEKLY", day_of_week: "FR"
- "jeden Samstag" → frequency: "WEEKLY", day_of_week: "SA"
- "jeden Sonntag" → frequency: "WEEKLY", day_of_week: "SU"

Für Enddaten:

- "jeden Dienstag bis Juni" → end_date: letzter Tag Juni im aktuellen Jahr
- "täglich bis 15. März" → end_date: "2026-03-15"
- Kein Enddatum angegeben → end_date weglassen (unendlich wiederholen)

WICHTIG: Nur simple Muster unterstützen (täglich, wöchentlich, monatlich). KEINE benutzerdefinierten Intervalle wie "alle 2 Wochen" oder "alle 3 Monate".

Beispiele:

- "Trag Fußball jeden Dienstag um 16 Uhr ein" → intent: create_event, entities: {title: "Fußball", time: "16:00", recurrence: {frequency: "WEEKLY", day_of_week: "TU"}}
- "Täglich um 9 Uhr Meeting bis Ende März" → intent: create_event, entities: {title: "Meeting", time: "09:00", recurrence: {frequency: "DAILY", end_date: "2026-03-31"}}
- "Monatlich am 1. Teambesprechung um 10 Uhr" → intent: create_event, entities: {title: "Teambesprechung", date: "2026-03-01", time: "10:00", recurrence: {frequency: "MONTHLY"}}

```

Also update the existing time-of-day defaults in the prompt to match user decisions exactly:

- "morgens" → 09:00 (keep)
- "nachmittags" → **15:00** (change from 14:00 to match user decision)
- "abends" → **19:00** (change from 18:00 to match user decision)

**2. Add createRecurringEvent to operations (src/calendar/operations.ts):**

Add import of `formatRRule` and `calculateNextOccurrences` from `./recurring.js`.
Add import of `CreateRecurringEventInput` from `./types.js`.

Create `createRecurringEvent` function:

```typescript
export async function createRecurringEvent(
  client: CalendarClient,
  input: CreateRecurringEventInput,
): Promise<{ event: CalendarEvent; nextOccurrences: string[] }> {
```

- Calculate start/end using existing `createEventDateTime`/`createEventEndDateTime`
- Call `formatRRule()` with frequency, dayOfWeek, endDate, and client.timezone
- Pass `recurrence: [rruleString]` in the Google Calendar API `events.insert` requestBody
- Map response to CalendarEvent (same pattern as existing `createEvent`)
- Call `calculateNextOccurrences()` with startDate, startTime, frequency, count=3, timezone
- Format occurrences as `dd.MM` strings (e.g., "18.02", "25.02", "04.03")
- Return `{ event, nextOccurrences }` where nextOccurrences is the formatted date strings array
- Use same error handling pattern as existing `createEvent`

**Also update all event mapping code in operations.ts** (in `listEvents`, `findEvents`, `createEvent`, `updateEvent`) to include `recurringEventId` in the mapped CalendarEvent object:

```typescript
recurringEventId: item.recurringEventId || undefined,
```

This populates the `recurringEventId` field added to CalendarEvent in Task 1, enabling Plan 04-03 to detect recurring event instances for deletion scope questions.
</action>
<verify>
Run `npx tsc --noEmit` — zero errors. Verify src/llm/prompts.ts contains "Wiederkehrende Termine" section and "Erweiterte Datumsauflösung" section. Verify "nachmittags" → 15:00 and "abends" → 19:00 in prompt. Verify src/calendar/operations.ts exports createRecurringEvent. Grep for "formatRRule" in operations.ts to confirm RRULE wiring. Grep for "recurringEventId" in operations.ts to confirm event mapping includes it.

**Runtime date parsing verification:** Create a temporary test script that calls `parseCalendarIntent` (from `src/llm/intent.ts`) with three German test inputs and validates the structured output:

1. `"Zahnarzt nächsten Dienstag um 10 Uhr"` — expect: date resolves to next Tuesday (not today), time = "10:00"
2. `"Jeden Mittwoch Fußball um 16 Uhr"` — expect: recurrence.frequency = "WEEKLY", recurrence.day_of_week = "WE", time = "16:00"
3. `"Meeting morgens"` — expect: time = "09:00"

Run via `npx tsx scripts/verify-date-parsing.ts` (create this temp script). Check that all three produce correct structured output. Delete the script after verification succeeds. If any test fails, adjust the prompt rules in prompts.ts until the LLM returns correct results.
</verify>
<done>
System prompt enhanced with German date parsing rules (relative dates, weekday resolution, vague time defaults matching user decisions) and recurring event detection rules (daily/weekly/monthly only, no custom intervals). createRecurringEvent function added to calendar operations, formatting RRULE strings and returning next 3 occurrences for confirmation messages. TypeScript compiles cleanly.
</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep -r "RecurrenceEntities" src/llm/types.ts` returns the interface definition
3. `grep -r "formatRRule" src/calendar/recurring.ts` returns the function
4. `grep -r "calculateNextOccurrences" src/calendar/recurring.ts` returns the function
5. `grep -r "trimRecurringEvent" src/calendar/recurring.ts` returns the function
6. `grep -r "createRecurringEvent" src/calendar/operations.ts` returns the function
7. `grep -r "Wiederkehrende Termine" src/llm/prompts.ts` returns the prompt section
8. `grep -r "nachmittags.*15:00" src/llm/prompts.ts` confirms updated time default
9. `grep -r "abends.*19:00" src/llm/prompts.ts` confirms updated time default
10. `grep -r "RRULE" src/calendar/recurring.ts` returns RRULE formatting code
11. `grep -r "recurrence" src/llm/intent.ts` returns tool schema extension
12. `grep -r "recurringEventId" src/calendar/types.ts` returns the field in CalendarEvent
13. `grep -r "recurringEventId" src/calendar/operations.ts` returns event mapping code
</verification>

<success_criteria>

- RecurrenceEntities type with frequency/day_of_week/end_date exists and validates via Zod
- LLM tool schema includes recurrence object in entities
- formatRRule generates correct RRULE strings (FREQ=WEEKLY;BYDAY=TU, FREQ=DAILY;UNTIL=... with UTC Z suffix)
- calculateNextOccurrences returns correct date progression for all three frequencies
- trimRecurringEvent updates recurring event RRULE to set UNTIL before given date (preserving past instances)
- System prompt includes German date parsing rules with deterministic weekday resolution
- System prompt includes recurring event detection with examples
- Vague time defaults match user decisions: morgens=09:00, mittags=12:00, nachmittags=15:00, abends=19:00
- createRecurringEvent creates Google Calendar event with RRULE recurrence field and returns next 3 occurrence dates
- All TypeScript compiles cleanly with zero errors
  </success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-features/04-01-SUMMARY.md`
</output>

---
phase: 01-foundation-signal-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/signal/sender.ts
  - src/signal/listener.ts
autonomous: true

must_haves:
  truths:
    - "Bot can send text messages to a Signal phone number"
    - "Bot receives incoming Signal messages as typed events"
    - "Bot deduplicates messages using idempotency store before processing"
    - "Bot processes messages through LLM intent extraction and responds"
  artifacts:
    - path: "src/signal/sender.ts"
      provides: "Signal message sending with error handling"
      exports: ["sendSignalMessage"]
      min_lines: 20
    - path: "src/signal/listener.ts"
      provides: "Message event handler with full processing pipeline"
      exports: ["setupMessageListener"]
      min_lines: 60
  key_links:
    - from: "src/signal/listener.ts"
      to: "src/signal/sender.ts"
      via: "sendSignalMessage call for responses"
      pattern: "sendSignalMessage"
    - from: "src/signal/listener.ts"
      to: "src/state/idempotency.ts"
      via: "IdempotencyStore.isProcessed check"
      pattern: "isProcessed|markProcessed"
    - from: "src/signal/listener.ts"
      to: "src/llm/intent.ts"
      via: "extractIntent call"
      pattern: "extractIntent"
    - from: "src/signal/listener.ts"
      to: "src/state/conversation.ts"
      via: "ConversationStore for state management"
      pattern: "conversationStore|ConversationStore"
    - from: "src/signal/sender.ts"
      to: "src/signal/client.ts"
      via: "SignalClient for sending"
      pattern: "SignalClient|signal"
---

<objective>
Create the Signal sender and message listener that form the core message processing pipeline.

Purpose: The sender provides outbound messaging capability. The listener is the heart of the bot -- it receives incoming Signal messages, checks idempotency, extracts intent via Claude LLM, generates responses, and sends them back via Signal. This replaces the WhatsApp webhook routes + BullMQ consumer with a simpler event-driven architecture.

Output: Working sender module and message listener with full processing pipeline.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-signal-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-signal-infrastructure/01-01-SUMMARY.md

@src/signal/client.ts
@src/signal/types.ts
@src/config/constants.ts
@src/utils/errors.ts
@src/utils/logger.ts
@src/llm/intent.ts
@src/llm/types.ts
@src/state/conversation.ts
@src/state/idempotency.ts
@src/state/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Signal message sender</name>
  <files>src/signal/sender.ts</files>
  <action>
    Create `src/signal/sender.ts` that exports a `sendSignalMessage` function.

    **Function signature:**
    ```typescript
    async function sendSignalMessage(
      client: SignalClient,
      recipient: string,
      text: string
    ): Promise<void>
    ```

    **Implementation:**
    - Import `SignalClient` type from `./client.js`
    - Import `SignalSendError` from `../utils/errors.js`
    - Import `logger` from `../utils/logger.js`
    - Call `client.sendMessage(recipient, text)` (signal-sdk method)
    - Wrap in try/catch:
      - On success: log at info level with `{ recipient, textLength: text.length }`
      - On failure: log at error level with `{ error, recipient }`, throw new `SignalSendError` with the original error message
    - Do NOT retry manually -- signal-sdk handles retries via its retryConfig (configured in client.ts)

    **Important:** If signal-sdk's sendMessage API differs from `client.sendMessage(recipient, text)` after Plan 01 is executed, adapt the call accordingly. Check the actual signal-sdk types/API from the installed package.

    Keep this module simple and focused. No message formatting, no templates -- just send text. Message formatting belongs in the listener/handler logic.

  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation.
    Verify export: `grep "export.*sendSignalMessage" src/signal/sender.ts`
    Verify error handling: `grep "SignalSendError" src/signal/sender.ts`
  </verify>
  <done>
    src/signal/sender.ts exports sendSignalMessage function.
    Function accepts SignalClient, recipient string, and text string.
    Function logs success/failure and throws SignalSendError on failure.
    TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Signal message listener with processing pipeline</name>
  <files>src/signal/listener.ts</files>
  <action>
    Create `src/signal/listener.ts` that exports a `setupMessageListener` function.

    **Function signature:**
    ```typescript
    function setupMessageListener(deps: MessageListenerDeps): void
    ```

    **MessageListenerDeps interface** (define in this file or in types.ts):
    ```typescript
    interface MessageListenerDeps {
      signalClient: SignalClient;
      anthropicClient: Anthropic;
      conversationStore: ConversationStore;
      idempotencyStore: IdempotencyStore;
    }
    ```

    **Implementation:**

    1. **Register event handler:** `deps.signalClient.on('message', async (message) => { ... })`

       **IMPORTANT: The signal-sdk event API shape is based on MEDIUM-HIGH confidence research.** Before implementing, read the installed signal-sdk package's TypeScript declarations (e.g., `node_modules/signal-sdk/dist/index.d.ts` or similar) to confirm:
       - The correct event name (might be `'message'`, `'data'`, `'envelope'`, etc.)
       - The callback signature (what argument shape the handler receives)
       - The correct method to access message text, sender, timestamp from the event payload
       Adapt the implementation below to match the actual API rather than blindly following these instructions.

    2. **Extract message data:** Parse the incoming message envelope:
       - Get `phoneNumber` from `envelope.source` (or `message.source` -- adapt to signal-sdk's actual event shape)
       - Get `messageId` from `envelope.timestamp.toString()`
       - Get `text` from `envelope.dataMessage?.message || ''`
       - Skip if no text (media-only messages, typing indicators, sync messages)
       - Skip if group message (for Phase 1, handle direct messages only)
       - Log received message at debug level

    3. **Idempotency check:**
       - Call `deps.idempotencyStore.isProcessed(messageId)`
       - If true: log at debug level "Duplicate message, skipping" and return
       - Mark as processed BEFORE processing (prevent race conditions on duplicate delivery): `deps.idempotencyStore.markProcessed(messageId)`

    4. **Process message through conversation + LLM pipeline:**
       - Get conversation state: `deps.conversationStore.getState(phoneNumber)`
       - Add user message to history: `deps.conversationStore.addToHistory(phoneNumber, 'user', text)`
       - Extract intent: `extractIntent(deps.anthropicClient, text, state?.messageHistory || [])`
       - Generate response based on intent type:
         - `greeting`: "Hello! I'm your family calendar assistant. You can ask me to add events, check your schedule, or manage existing events."
         - `help`: "I can help you with:\n- Adding events: 'Add soccer practice Tuesday at 4pm'\n- Checking schedule: 'What's on today?'\n- Editing events: 'Move dentist to Thursday'\n- Deleting events: 'Cancel soccer this week'"
         - `create_event`, `query_events`, `update_event`, `delete_event`: For Phase 1, respond with: "I understood you want to [intent type]. Calendar integration is coming in Phase 2! For now, I can confirm I understood: [summarize extracted entities]."
         - `unclear`: Use `intent.clarification_needed` if available, otherwise: "I'm not sure what you mean. Could you rephrase that? You can ask me about your calendar."
       - Log intent extraction result at info level: `{ phoneNumber, intent: intent.intent, confidence: intent.confidence }`

    5. **Send response:**
       - Call `sendSignalMessage(deps.signalClient, phoneNumber, response)`
       - Add assistant response to history: `deps.conversationStore.addToHistory(phoneNumber, 'assistant', response)`

    6. **Error handling:**
       - Wrap the entire handler in try/catch
       - On error: log at error level with `{ error, phoneNumber, messageId }`
       - Attempt to send error response to user: "Sorry, I had trouble processing your message. Please try again."
       - Do NOT re-throw (event handlers should not crash the daemon)

    **Imports needed:**
    - `SignalClient` from `./client.js`
    - `sendSignalMessage` from `./sender.js`
    - `Anthropic` from `@anthropic-ai/sdk`
    - `ConversationStore` from `../state/conversation.js`
    - `IdempotencyStore` from `../state/idempotency.js`
    - `extractIntent` from `../llm/intent.js`
    - `logger` from `../utils/logger.js`

  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation.
    Verify export: `grep "export.*setupMessageListener" src/signal/listener.ts`
    Verify pipeline wiring:
    - `grep "isProcessed\|markProcessed" src/signal/listener.ts` (idempotency)
    - `grep "extractIntent" src/signal/listener.ts` (LLM)
    - `grep "conversationStore" src/signal/listener.ts` (state)
    - `grep "sendSignalMessage" src/signal/listener.ts` (response)
  </verify>
  <done>
    src/signal/listener.ts exports setupMessageListener function.
    Listener handles incoming messages with: skip non-text, idempotency check, conversation state, LLM intent extraction, response generation, Signal reply.
    Error handling prevents daemon crashes on individual message failures.
    All pipeline components are wired: idempotency -> conversation -> LLM -> response -> send.
    TypeScript compilation passes.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all files in src/signal/
2. Listener imports and uses: IdempotencyStore, ConversationStore, extractIntent, sendSignalMessage
3. Sender wraps signal-sdk send with error handling
4. No `any` types used
5. Error handling in listener catches all errors and does not crash the event loop
</verification>

<success_criteria>

- Signal sender can send text messages with error handling and logging
- Signal listener receives messages, deduplicates, extracts intent via Claude, and responds
- Full processing pipeline is wired: receive -> deduplicate -> state -> LLM -> respond
- Listener gracefully handles errors without crashing the daemon
- Phase 1 responds to all intent types with appropriate messages (calendar stubs for Phase 2)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-signal-infrastructure/01-02-SUMMARY.md`
</output>
